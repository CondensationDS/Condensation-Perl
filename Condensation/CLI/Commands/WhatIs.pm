use Fcntl;

# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0);
	my $node001 = CDS::Parser::Node->new(0);
	my $node002 = CDS::Parser::Node->new(0);
	my $node003 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node004 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&whatIs});
	$cds->addArrow($node001, 1, 0, 'what');
	$help->addArrow($node000, 1, 0, 'what');
	$node000->addArrow($node003, 1, 0, 'is');
	$node001->addArrow($node002, 1, 0, 'is');
	$node002->addArrow($node004, 1, 0, 'TEXT', \&collectText);
}

sub collectText($o, $label, $value) {
	$o:text = $value;
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# HTML FOLDER NAME what-is
# HTML TITLE What is
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds what is TEXT');
	$ui->p('Tells what TEXT could be under the current configuration.');
	$ui->space;
}

sub whatIs($o, $cmd) {
	$cmd->collect($o);
	$o:butNot = [];

	$o:ui->space;
	$o:ui->title($o:ui->blue($o:text), ' may be …');

	$o->test('ACCOUNT', 'an ACCOUNT', sub { shift->url });
	$o->test('AESKEY', 'an AESKEY', sub { unpack('H*', shift) });
	$o->test('BOX', 'a BOX', sub { shift->url });
	$o->test('BOXLABEL', 'a BOXLABEL', sub { shift });
	$o->test('FILE', 'a FILE', \&fileResult);
	$o->test('FILENAME', 'a FILENAME', \&fileResult);
	$o->test('FOLDER', 'a FOLDER', \&fileResult);
	$o->test('GROUP', 'a GROUP on this system', sub { shift });
	$o->test('HASH', 'a HASH or ACTOR hash', sub { shift->hex });
	$o->test('KEYPAIR', 'a KEYPAIR', \&keyPairResult);
	$o->test('LABEL', 'a remembered LABEL', sub { shift });
	$o->test('OBJECT', 'an OBJECT', sub { shift->url });
	$o->test('OBJECTFILE', 'an OBJECTFILE', \&objectFileResult);
	$o->test('STORE', 'a STORE', sub { shift->url });
	$o->test('USER', 'a USER on this system', sub { shift });

	for my $butNot (@$o:butNot) {
		$o:ui->space;
		$o:ui->line('… but not ', $butNot:text, ', because:');
		for my $warning (@$butNot:warnings) {
			$o:ui->warning($warning);
		}
	}

	$o:ui->space;
}

sub test($o, $expect, $text, $resultHandler) {
	my $token = CDS::Parser::Token->new($o:actor, $o:text);
	my $result = $token->produce($expect);
	if (defined $result) {
		my $whichOne = &$resultHandler($result);
		$o:ui->line('… ', $text, '  ', $o:ui->gray($whichOne));
	} elsif (scalar @$token:warnings) {
		push @$o:butNot, {text => $text, warnings => $token:warnings};
	}
}

sub keyPairResult($keyPairToken) {
	return $keyPairToken->file.' ('.$keyPairToken->keyPair->publicKey->hash->hex.')';
}

sub objectFileResult($objectFileToken) {
	return $objectFileToken->file if $objectFileToken->object->byteLength > 1024 * 1024;
	return $objectFileToken->file.' ('.$objectFileToken->object->calculateHash->hex.')';
}

sub fileResult($file) {
	my @s = stat $file;
	my $label =
		! scalar @s ? ' (non-existing)' :
		Fcntl::S_ISDIR($s[2]) ? ' (folder)' :
		Fcntl::S_ISREG($s[2]) ? ' (file, '.$s[7].' bytes)' :
		Fcntl::S_ISLNK($s[2]) ? ' (symbolic link)' :
		Fcntl::S_ISBLK($s[2]) ? ' (block device)' :
		Fcntl::S_ISCHR($s[2]) ? ' (char device)' :
		Fcntl::S_ISSOCK($s[2]) ? ' (socket)' :
		Fcntl::S_ISFIFO($s[2]) ? ' (pipe)' : ' (unknown type)';

	return $file.$label;
}
