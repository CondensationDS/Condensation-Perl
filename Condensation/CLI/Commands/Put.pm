# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0);
	my $node001 = CDS::Parser::Node->new(0);
	my $node002 = CDS::Parser::Node->new(0);
	my $node003 = CDS::Parser::Node->new(0);
	my $node004 = CDS::Parser::Node->new(0);
	my $node005 = CDS::Parser::Node->new(0);
	my $node006 = CDS::Parser::Node->new(0);
	my $node007 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node008 = CDS::Parser::Node->new(0);
	my $node009 = CDS::Parser::Node->new(0);
	my $node010 = CDS::Parser::Node->new(0);
	my $node011 = CDS::Parser::Node->new(0);
	my $node012 = CDS::Parser::Node->new(1);
	my $node013 = CDS::Parser::Node->new(0);
	my $node014 = CDS::Parser::Node->new(0);
	my $node015 = CDS::Parser::Node->new(0);
	my $node016 = CDS::Parser::Node->new(0);
	my $node017 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&put});
	$cds->addArrow($node000, 1, 0, 'put');
	$cds->addArrow($node001, 1, 0, 'put');
	$cds->addArrow($node002, 1, 0, 'put');
	$help->addArrow($node007, 1, 0, 'put');
	$node000->addArrow($node012, 1, 0, 'OBJECTFILE', \&collectObjectfile);
	$node001->addArrow($node003, 1, 0, 'object');
	$node002->addArrow($node004, 1, 0, 'public');
	$node003->addArrow($node008, 1, 0, 'with');
	$node004->addArrow($node005, 1, 0, 'key');
	$node005->addArrow($node006, 1, 0, 'of');
	$node006->addArrow($node012, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node008->addDefault($node009);
	$node008->addDefault($node011);
	$node009->addArrow($node009, 1, 0, 'HASH', \&collectHash);
	$node009->addArrow($node010, 1, 0, 'HASH', \&collectHash);
	$node010->addArrow($node011, 1, 0, 'and');
	$node011->addArrow($node012, 1, 0, 'FILE', \&collectFile);
	$node012->addArrow($node013, 1, 0, 'encrypted');
	$node012->addDefault($node015);
	$node013->addArrow($node014, 1, 0, 'with');
	$node014->addArrow($node015, 1, 0, 'AESKEY', \&collectAeskey);
	$node015->addArrow($node016, 1, 0, 'onto');
	$node015->addDefault($node017);
	$node016->addArrow($node016, 1, 0, 'STORE', \&collectStore);
	$node016->addArrow($node017, 1, 0, 'STORE', \&collectStore);
}

sub collectAeskey($o, $label, $value) {
	$o:aesKey = $value;
}

sub collectFile($o, $label, $value) {
	$o:dataFile = $value;
}

sub collectHash($o, $label, $value) {
	push @$o:hashes, $value;
}

sub collectKeypair($o, $label, $value) {
	$o:object = $value->keyPair->publicKey->object;
}

sub collectObjectfile($o, $label, $value) {
	$o:objectFile = $value;
}

sub collectStore($o, $label, $value) {
	push @$o:stores, $value;
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# HTML FOLDER NAME store-put
# HTML TITLE Put
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds put FILE* [onto STORE*]');
	$ui->p('Uploads object files onto object stores. If no stores are provided, the selected store is used. If an upload fails, the program immediately quits with exit code 1.');
	$ui->space;
	$ui->command('cds put FILE encrypted with AESKEY [onto STORE*]');
	$ui->p('Encrypts the object before the upload.');
	$ui->space;
	$ui->command('cds put object with [HASH* and] FILE …');
	$ui->p('Creates an object with the HASHes as hash list and FILE as data.');
	$ui->space;
	$ui->command('cds put public key of KEYPAIR …');
	$ui->p('Uploads the public key of the indicated key pair onto the store.');
	$ui->space;
}

sub put($o, $cmd) {
	$o:hashes = [];
	$o:stores = [];
	$cmd->collect($o);

	# Stores
	push @$o:stores, $o:actor->preferredStore if ! scalar @$o:stores;

	$o:get = [];
	return $o->putObject($o:object) if $o:object;
	return $o->putObjectFile if $o:objectFile;
	$o->putConstructedFile;
}

sub putObjectFile($o) {
	my $object = $o:objectFile->object;

	# Display object information
	$o:ui->space;
	$o:ui->title('Uploading ', $o:objectFile->file, '  ', $o:ui->gray($o:ui->niceFileSize($object->byteLength)));
	$o:ui->line($object->hashesCount == 1 ? '1 hash' : $object->hashesCount.' hashes');
	$o:ui->line($o:ui->niceFileSize(length $object->data).' data');
	$o:ui->space;

	# Upload
	$o->putObject($object);
}

sub putConstructedFile($o) {
	# Create the object
	my $data = CDS->readBytesFromFile($o:dataFile) // return $o:ui->error('Unable to read "', $o:dataFile, '".');
	my $header = pack('L>', scalar @$o:hashes) . join('', map { $_->bytes } @$o:hashes);
	my $object = CDS::Object->create($header, $data);

	# Display object information
	$o:ui->space;
	$o:ui->title('Uploading new object  ', $o:ui->gray($o:ui->niceFileSize(length $object->bytes)));
	$o:ui->line($object->hashesCount == 1 ? '1 hash' : $object->hashesCount.' hashes');
	$o:ui->line($o:ui->niceFileSize(length $object->data).' data from ', $o:dataFile);
	$o:ui->space;

	# Upload
	$o->putObject($object);
}

sub putObject($o, $object) {
	my $keyPair = $o:actor->preferredKeyPairToken->keyPair;

	# Encrypt it if desired
	my $objectBytes;
	if (defined $o:aesKey) {
		$object = $object->crypt($o:aesKey);
		unshift @$o:get, ' decrypted with ', unpack('H*', $o:aesKey), ' ';
	}

	# Calculate the hash
	my $hash = $object->calculateHash;

	# Upload the object
	my $successfulStore;
	for my $store (@$o:stores) {
		my $error = $store->put($hash, $object, $keyPair);
		next if $error;
		$o:ui->pGreen('The object was uploaded onto ', $store->url, '.');
		$successfulStore = $store;
	}

	# Show the corresponding download line
	return if ! $successfulStore;
	$o:ui->space;
	$o:ui->line('To download the object, type:');
	$o:ui->line($o:ui->gold('cds get ', $hash->hex), $o:ui->gray(' on ', $successfulStore->url, @$o:get));
	$o:ui->space;
}
