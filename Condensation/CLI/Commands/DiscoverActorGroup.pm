# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0);
	my $node001 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node002 = CDS::Parser::Node->new(1);
	my $node003 = CDS::Parser::Node->new(0);
	my $node004 = CDS::Parser::Node->new(0);
	my $node005 = CDS::Parser::Node->new(0);
	my $node006 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&showActorGroupCmd});
	my $node007 = CDS::Parser::Node->new(0);
	my $node008 = CDS::Parser::Node->new(0);
	my $node009 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&discover});
	my $node010 = CDS::Parser::Node->new(0);
	my $node011 = CDS::Parser::Node->new(0);
	my $node012 = CDS::Parser::Node->new(0);
	my $node013 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&discover});
	$cds->addArrow($node000, 1, 0, 'show');
	$cds->addArrow($node002, 1, 0, 'discover');
	$help->addArrow($node001, 1, 0, 'discover');
	$help->addArrow($node001, 1, 0, 'rediscover');
	$node000->addArrow($node006, 1, 0, 'ACTORGROUP', \&collectActorgroup);
	$node002->addDefault($node003);
	$node002->addDefault($node004);
	$node002->addDefault($node005);
	$node002->addArrow($node009, 1, 0, 'me', \&collectMe);
	$node002->addArrow($node013, 1, 0, 'ACTORGROUP', \&collectActorgroup1);
	$node003->addArrow($node003, 1, 0, 'ACCOUNT', \&collectAccount);
	$node003->addArrow($node009, 1, 1, 'ACCOUNT', \&collectAccount);
	$node004->addArrow($node004, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node004->addArrow($node007, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node005->addArrow($node005, 1, 0, 'ACTOR', \&collectActor);
	$node005->addArrow($node007, 1, 0, 'ACTOR', \&collectActor);
	$node007->addArrow($node008, 1, 0, 'on');
	$node007->addDefault($node009);
	$node008->addArrow($node009, 1, 0, 'STORE', \&collectStore);
	$node009->addArrow($node010, 1, 0, 'and');
	$node010->addArrow($node011, 1, 0, 'remember');
	$node011->addArrow($node012, 1, 0, 'as');
	$node012->addArrow($node013, 1, 0, 'TEXT', \&collectText);
}

sub collectAccount($o, $label, $value) {
	push @$o:accounts, $value;
}

sub collectActor($o, $label, $value) {
	push @$o:actorHashes, $value;
}

sub collectActorgroup($o, $label, $value) {
	$o:actorGroupToken = $value;
}

sub collectActorgroup1($o, $label, $value) {
	$o:actorGroupToken = $value;
	$o:label = $value->label;
}

sub collectKeypair($o, $label, $value) {
	push @$o:actorHashes, $value->keyPair->publicKey->hash;
}

sub collectMe($o, $label, $value) {
	$o:me = 1;
}

sub collectStore($o, $label, $value) {
	$o:store = $value;
}

sub collectText($o, $label, $value) {
	$o:label = $value;
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# HTML FOLDER NAME discover
# HTML TITLE Discover actor groups
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds discover ACCOUNT');
	$ui->command('cds discover ACTOR [on STORE]');
	$ui->p('Discovers the actor group the given account belongs to. Only active group members are discovered.');
	$ui->space;
	$ui->command('cds discover ACCOUNT*');
	$ui->command('cds discover ACTOR* on STORE');
	$ui->p('Same as above, but starts discovery with multiple accounts. All accounts must belong to the same actor group.');
	$ui->p('Note that this rarely makes sense. The actor group discovery algorithm reliably discovers an actor group from a single account.');
	$ui->space;
	$ui->command('cds discover me');
	$ui->p('Discovers your own actor group.');
	$ui->space;
	$ui->command('â€¦ and remember as TEXT');
	$ui->p('The discovered actor group is remembered as TEXT. See "cds help remember" for details.');
	$ui->space;
	$ui->command('cds discover ACTORGROUP');
	$ui->p('Updates a previously remembered actor group.');
	$ui->space;
	$ui->command('cds show ACTORGROUP');
	$ui->p('Shows a previously discovered and remembered actor group.');
	$ui->space;
}

sub discover($o, $cmd) {
	$o:accounts = [];
	$o:actorHashes = [];
	$cmd->collect($o);

	# Discover
	my $builder = $o->prepareBuilder;
	my ($actorGroup, $cards, $nodes) = $builder->discover($o:actor->keyPair, $o);

	# Show the graph
	$o:ui->space;
	$o:ui->title('Graph');
	for my $node (@$nodes) {
		my $status = $node->status eq 'active' ? $o:ui->green('active  ') : $o:ui->gray('idle    ');
		$o:ui->line($o:ui->blue($node->actorHash->hex), ' on ', $node->storeUrl, '  ', $status, $o:ui->gray($o:ui->niceDateTime($node->revision)));
		$o:ui->pushIndent;
		for my $link ($node->links) {
			my $isMostRecentInformation = $link->revision == $link->node->revision;
			my $color = $isMostRecentInformation ? 246 : 250;
			$o:ui->line($link->node->actorHash->shortHex, ' on ', $link->node->storeUrl, '  ', $o:ui->foreground($color, $o:ui->left(8, $link->status), $o:ui->niceDateTime($link->revision)));
		}
		$o:ui->popIndent;
	}

	# Show all accounts
	$o->showActorGroup($actorGroup);

	# Show all cards
	$o:ui->space;
	$o:ui->title('Cards');
	for my $card (@$cards) {
		$o:ui->line($o:ui->gold('cds show record ', $card->cardHash->hex, ' on ', $card->storeUrl));
	}

	# Remember the actor group if desired
	if ($o:label) {
		my $selector = $o:actor->labelSelector($o:label);

		my $record = CDS::Record->new;
		my $actorGroupRecord = $record->add('actor group');
		$actorGroupRecord->add('discovered')->addInteger(CDS->now);
		$actorGroupRecord->addRecord($actorGroup->toBuilder->toRecord(1)->children);
		$selector->set($record);

		for my $publicKey ($actorGroup->publicKeys) {
			$selector->addObject($publicKey->hash, $publicKey->object);
		}

		$o:actor->saveOrShowError // return;
	}

	$o:ui->space;
}

sub prepareBuilder($o) {
	# Actor group
	return $o:actorGroupToken->actorGroup->toBuilder if $o:actorGroupToken;

	# Other than actor group
	my $builder = CDS::ActorGroupBuilder->new;
	$builder->addKnownPublicKey($o:actor->keyPair->publicKey);

	# Me
	$builder->addMember($o:actor->messagingStoreUrl, $o:actor->keyPair->publicKey->hash) if $o:me;

	# Accounts
	for my $account (@$o:accounts) {
		$builder->addMember($account->cliStore->url, $account->actorHash);
	}

	# Actors on store
	if (scalar @$o:actorHashes) {
		my $store = $o:store // $o:actor->preferredStore;
		for my $actorHash (@$o:actorHashes) {
			$builder->addMember($actorHash, $store->url);
		}
	}

	return $builder;
}

sub showActorGroupCmd($o, $cmd) {
	$cmd->collect($o);
	$o->showActorGroup($o:actorGroupToken->actorGroup);
	$o:ui->space;
}

sub showActorGroup($o, $actorGroup) {
	$o:ui->space;
	$o:ui->title(length $o:label ? 'Actors of '.$o:label : 'Actor group');
	for my $member ($actorGroup->members) {
		my $date = $member->revision ? $o:ui->niceDateTimeLocal($member->revision) : '                   ';
		my $status = $member->isActive ? $o:ui->green('active  ') : $o:ui->gray('idle    ');
		my $storeReference = $o:actor->blueStoreUrlReference($member->storeUrl);
		$o:ui->line($o:ui->gray($date), '  ', $status, '  ', $member->actorOnStore->publicKey->hash->hex, ' on ', $storeReference);
	}

	if ($actorGroup->entrustedActorsRevision) {
		$o:ui->space;
		$o:ui->title(length $o:label ? 'Actors entrusted by '.$o:label : 'Entrusted actors');
		$o:ui->line($o:ui->gray($o:ui->niceDateTimeLocal($actorGroup->entrustedActorsRevision)));
		for my $actor ($actorGroup->entrustedActors) {
			my $storeReference = $o:actor->storeUrlReference($actor->storeUrl);
			$o:ui->line($actor->actorOnStore->publicKey->hash->hex, $o:ui->gray(' on ', $storeReference));
		}

		$o:ui->line($o:ui->gray('(none)')) if ! scalar $actorGroup->entrustedActors;
	}
}

sub onDiscoverActorGroupVerifyStore($o, $storeUrl, $actorHash) {
	return $o:actor->storeForUrl($storeUrl);
}

sub onDiscoverActorGroupInvalidPublicKey($o, $actorHash, $store, $reason) {
	$o:ui->warning('Public key ', $actorHash->hex, ' on ', $store->url, ' is invalid: ', $reason);
}

sub onDiscoverActorGroupInvalidCard($o, $actorOnStore, $envelopeHash, $reason) {
	$o:ui->warning('Card ', $envelopeHash->hex, ' on ', $actorOnStore->store->url, ' is invalid: ', $reason);
}

sub onDiscoverActorGroupStoreError($o, $store, $error) {
}
