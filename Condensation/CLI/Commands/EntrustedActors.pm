# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0);
	my $node001 = CDS::Parser::Node->new(0);
	my $node002 = CDS::Parser::Node->new(0);
	my $node003 = CDS::Parser::Node->new(0);
	my $node004 = CDS::Parser::Node->new(0);
	my $node005 = CDS::Parser::Node->new(0);
	my $node006 = CDS::Parser::Node->new(0);
	my $node007 = CDS::Parser::Node->new(0);
	my $node008 = CDS::Parser::Node->new(0);
	my $node009 = CDS::Parser::Node->new(0);
	my $node010 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node011 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&show});
	my $node012 = CDS::Parser::Node->new(0);
	my $node013 = CDS::Parser::Node->new(0);
	my $node014 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&doNotEntrust});
	my $node015 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&entrust});
	my $node016 = CDS::Parser::Node->new(0);
	$cds->addArrow($node001, 1, 0, 'show');
	$cds->addArrow($node003, 1, 0, 'do');
	$cds->addArrow($node005, 1, 0, 'entrust');
	$help->addArrow($node000, 1, 0, 'entrusted');
	$node000->addArrow($node010, 1, 0, 'actors');
	$node001->addArrow($node002, 1, 0, 'entrusted');
	$node002->addArrow($node011, 1, 0, 'actors');
	$node003->addArrow($node004, 1, 0, 'not');
	$node004->addArrow($node008, 1, 0, 'entrust');
	$node005->addDefault($node006);
	$node005->addDefault($node007);
	$node005->addArrow($node012, 1, 0, 'ACTOR', \&collectActor);
	$node006->addArrow($node006, 1, 0, 'ACCOUNT', \&collectAccount);
	$node006->addArrow($node015, 1, 1, 'ACCOUNT', \&collectAccount);
	$node007->addArrow($node007, 1, 0, 'ACTOR', \&collectActor1);
	$node007->addArrow($node015, 1, 0, 'ACTOR', \&collectActor1);
	$node008->addDefault($node009);
	$node009->addArrow($node009, 1, 0, 'ACTOR', \&collectActor2);
	$node009->addArrow($node014, 1, 0, 'ACTOR', \&collectActor2);
	$node012->addArrow($node013, 1, 0, 'on');
	$node013->addArrow($node015, 1, 0, 'STORE', \&collectStore);
	$node015->addArrow($node016, 1, 0, 'and');
	$node016->addDefault($node005);
}

sub collectAccount($o, $label, $value) {
	push @$o:accountTokens, $value;
}

sub collectActor($o, $label, $value) {
	$o:actorHash = $value;
}

sub collectActor1($o, $label, $value) {
	push @$o:accountTokens, CDS::AccountToken->new($o:actor->preferredStore, $value);
}

sub collectActor2($o, $label, $value) {
	push @$o:actorHashes, $value;
}

sub collectStore($o, $label, $value) {
	push @$o:accountTokens, CDS::AccountToken->new($value, $o:actorHash);
	delete $o:actorHash;
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# HTML FOLDER NAME entrusted-actors
# HTML TITLE Entrusted actors
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds show entrusted actors');
	$ui->p('Shows all entrusted actors.');
	$ui->space;
	$ui->command('cds entrust ACCOUNT*');
	$ui->command('cds entrust ACTOR on STORE');
	$ui->p('Adds the indicated entrusted actors. Entrusted actors can read our private data and messages. The public key of the entrusted actor must be available on the store.');
	$ui->space;
	$ui->command('cds do not entrust ACTOR*');
	$ui->p('Removes the indicated entrusted actors.');
	$ui->space;
	$ui->p('After modifying the entrusted actors, you should "cds announce" yourself to publish the changes.');
	$ui->space;
}

sub show($o, $cmd) {
	my $builder = CDS::ActorGroupBuilder->new;
	$builder->parseEntrustedActorList($o:actor->entrustedActorsSelector->record, 1);

	my @actors = $builder->entrustedActors;
	for my $actor (@actors) {
		my $storeReference = $o:actor->storeUrlReference($actor->storeUrl);
		$o:ui->line($actor->hash->hex, $o:ui->gray(' on ', $storeReference));
	}

	return if scalar @actors;
	$o:ui->line($o:ui->gray('none'));
}

sub entrust($o, $cmd) {
	$o:accountTokens = [];
	$cmd->collect($o);

	# Get the list of currently entrusted actors
	my $entrusted = $o->createEntrustedActorsIndex;

	# Add new actors
	for my $accountToken (@$o:accountTokens) {
		my $actorHash = $accountToken->actorHash;

		# Check if the key is already entrusted
		if ($entrusted->{$accountToken->url}) {
			$o:ui->pOrange($accountToken->url, ' is already entrusted.');
			next;
		}

		# Get the public key
		my ($publicKey, $invalidReason, $storeError) = $o:actor->keyPair->getPublicKey($actorHash, $accountToken->cliStore);
		if (defined $storeError) {
			$o:ui->pRed('Unable to get the public key ', $actorHash->hex, ' from ', $accountToken->cliStore->url, ': ', $storeError);
			next;
		}

		if (defined $invalidReason) {
			$o:ui->pRed('Unable to get the public key ', $actorHash->hex, ' from ', $accountToken->cliStore->url, ': ', $invalidReason);
			next;
		}

		# Add it
		$o:actor->entrust($accountToken->cliStore->url, $publicKey);
		$o:ui->pGreen($entrusted->{$actorHash->hex} ? 'Updated ' : 'Added ', $actorHash->hex, ' as entrusted actor.');
	}

	# Save
	$o:actor->saveOrShowError;
}

sub doNotEntrust($o, $cmd) {
	$o:actorHashes = [];
	$cmd->collect($o);

	# Get the list of currently entrusted actors
	my $entrusted = $o->createEntrustedActorsIndex;

	# Remove entrusted actors
	for my $actorHash (@$o:actorHashes) {
		if ($entrusted->{$actorHash->hex}) {
			$o:actor->doNotEntrust($actorHash);
			$o:ui->pGreen('Removed ', $actorHash->hex, ' from the list of entrusted actors.');
		} else {
			$o:ui->pOrange($actorHash->hex, ' is not entrusted.');
		}
	}

	# Save
	$o:actor->saveOrShowError;
}

sub createEntrustedActorsIndex($o) {
	my $builder = CDS::ActorGroupBuilder->new;
	$builder->parseEntrustedActorList($o:actor->entrustedActorsSelector->record, 1);

	my $index = {};
	for my $actor ($builder->entrustedActors) {
		my $url = $actor->storeUrl.'/accounts/'.$actor->hash->hex;
		$index->{$actor->hash->hex} = 1;
		$index->{$url} = 1;
	}

	return $index;
}
