# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0);
	my $node001 = CDS::Parser::Node->new(0);
	my $node002 = CDS::Parser::Node->new(0);
	my $node003 = CDS::Parser::Node->new(0);
	my $node004 = CDS::Parser::Node->new(0);
	my $node005 = CDS::Parser::Node->new(0);
	my $node006 = CDS::Parser::Node->new(0);
	my $node007 = CDS::Parser::Node->new(0);
	my $node008 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node009 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&showMessagesOfSelected});
	my $node010 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&showMyMessages});
	my $node011 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&showOurMessages});
	my $node012 = CDS::Parser::Node->new(1);
	my $node013 = CDS::Parser::Node->new(0);
	my $node014 = CDS::Parser::Node->new(0);
	my $node015 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&showMessages});
	$cds->addArrow($node001, 1, 0, 'show');
	$cds->addArrow($node002, 1, 0, 'show');
	$cds->addArrow($node003, 1, 0, 'show');
	$cds->addArrow($node004, 1, 0, 'show');
	$help->addArrow($node000, 1, 0, 'show');
	$node000->addArrow($node008, 1, 0, 'messages');
	$node001->addArrow($node005, 1, 0, 'messages');
	$node002->addArrow($node006, 1, 0, 'my');
	$node003->addArrow($node009, 1, 0, 'messages');
	$node004->addArrow($node007, 1, 0, 'our');
	$node005->addArrow($node012, 1, 0, 'of');
	$node006->addArrow($node010, 1, 0, 'messages');
	$node007->addArrow($node011, 1, 0, 'messages');
	$node012->addArrow($node013, 1, 0, 'ACTOR', \&collectActor);
	$node012->addArrow($node013, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node012->addArrow($node015, 1, 1, 'ACCOUNT', \&collectAccount);
	$node012->addArrow($node015, 1, 0, 'ACTOR', \&collectActor1);
	$node012->addArrow($node015, 1, 0, 'ACTORGROUP', \&collectActorgroup);
	$node012->addArrow($node015, 1, 0, 'KEYPAIR', \&collectKeypair1);
	$node013->addArrow($node014, 1, 0, 'on');
	$node014->addArrow($node015, 1, 0, 'STORE', \&collectStore);
}

sub collectAccount($o, $label, $value) {
	push @$o:accountTokens, $value;
}

sub collectActor($o, $label, $value) {
	$o:actorHash = $value;
}

sub collectActor1($o, $label, $value) {
	push @$o:accountTokens, CDS::AccountToken->new($o:actor->preferredStore, $value);
}

sub collectActorgroup($o, $label, $value) {
	for my $member ($value->actorGroup->members) {
	push @$o:accountTokens, CDS::AccountToken->new($member->actorOnStore->store, $member->actorOnStore->publicKey->hash);
	}
}

sub collectKeypair($o, $label, $value) {
	$o:keyPairToken = $value;
	$o:actorHash = $value->keyPair->publicKey->hash;
}

sub collectKeypair1($o, $label, $value) {
	$o:keyPairToken = $value;
	push @$o:accountTokens, CDS::AccountToken->new($o:actor->preferredStore, $value->publicKey->hash);
}

sub collectStore($o, $label, $value) {
	push @$o:accountTokens, CDS::AccountToken->new($value, $o:actorHash);
	delete $o:actorHash;
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# INCLUDE ShowMessages/ProcessAccount.pm

# HTML FOLDER NAME show-messages
# HTML TITLE Show messages
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds show messages of ACCOUNT');
	$ui->command('cds show messages of ACTOR|KEYPAIR [on STORE]');
	$ui->p('Shows all (unprocessed) messages of an actor ordered by their envelope hash. If store is omitted, the selected store is used.');
	$ui->space;
	$ui->command('cds show messages of ACTORGROUP');
	$ui->p('Shows all messages of all actors of that group.');
	$ui->space;
	$ui->command('cds show messages');
	$ui->p('Shows the messages of the selected key pair on the selected store.');
	$ui->space;
	$ui->command('cds show my messages');
	$ui->p('Shows your messages.');
	$ui->space;
	$ui->command('cds show our messages');
	$ui->p('Shows all messages of your actor group.');
	$ui->space;
	$ui->p('Unprocessed messages are stored in the message box of an actor. Each entry points to an envelope, which in turn points to a record object. The envelope is signed by the sender, but does not hold any date. If the application relies on dates, it must include this date in the message.');
	$ui->space;
	$ui->p('While the envelope hash is stored on the actor\'s store, the envelope and the message are stored on the sender\'s store, and are downloaded from there. Depending on the reachability and responsiveness of that store, messages may not always be accessible.');
	$ui->space;
	$ui->p('Senders typically keep sent messages for about 10 days on their store. After that, the envelope hash may still be in the message box, but the actual message may have vanished.');
	$ui->space;
}

sub showMessagesOfSelected($o, $cmd) {
	$o:keyPairToken = $o:actor->preferredKeyPairToken;
	$o->processAccounts(CDS::AccountToken->new($o:actor->preferredStore, $o:actor->preferredActorHash));
}

sub showMyMessages($o, $cmd) {
	$o:keyPairToken = $o:actor->keyPairToken;
	my $actorHash = $o:actor->keyPair->publicKey->hash;
	my $store = $o:actor->messagingStore;
	$o->processAccounts(CDS::AccountToken->new($store, $actorHash));
}

sub showOurMessages($o, $cmd) {
	$o:keyPairToken = $o:actor->keyPairToken;

	my @accountTokens;
	for my $child ($o:actor->actorGroupSelector->children) {
		next if $child->child('revoked')->isSet;
		next if ! $child->child('active')->isSet;

		my $record = $child->record;
		my $actorHash = $record->child('hash')->hashValue // next;
		my $storeUrl = $record->child('store')->textValue;
		my $store = $o:actor->storeForUrl($storeUrl) // next;
		push @accountTokens, CDS::AccountToken->new($store, $actorHash);
	}

	$o->processAccounts(@accountTokens);
}

sub showMessages($o, $cmd) {
	$o:accountTokens = [];
	$cmd->collect($o);

	# Unless a key pair was provided, use the selected key pair
	$o:keyPairToken = $o:actor->keyPairToken if ! $o:keyPairToken;

	$o->processAccounts(@$o:accountTokens);
}

sub processAccounts($o; @accountTokens) {
	# Initialize the statistics
	$o:countValid = 0;
	$o:countInvalid = 0;

	# Show the messages of all selected accounts
	for my $accountToken (@_) {
		CDS::Commands::ShowMessages::ProcessAccount->new($o, $accountToken);
	}

	# Show the statistics
	$o:ui->space;
	$o:ui->title('Total');
	$o:ui->line(scalar @_, ' account', scalar @_ == 1 ? '' : 's');
	$o:ui->line($o:countValid, ' message', $o:countValid == 1 ? '' : 's');
	$o:ui->line($o:countInvalid, ' invalid message', $o:countInvalid == 1 ? '' : 's') if $o:countInvalid;
	$o:ui->space;
}
