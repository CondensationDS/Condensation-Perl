# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0);
	my $node001 = CDS::Parser::Node->new(0);
	my $node002 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node003 = CDS::Parser::Node->new(0);
	my $node004 = CDS::Parser::Node->new(0);
	my $node005 = CDS::Parser::Node->new(0);
	my $node006 = CDS::Parser::Node->new(0);
	my $node007 = CDS::Parser::Node->new(0);
	my $node008 = CDS::Parser::Node->new(0);
	my $node009 = CDS::Parser::Node->new(0);
	my $node010 = CDS::Parser::Node->new(0);
	my $node011 = CDS::Parser::Node->new(0);
	my $node012 = CDS::Parser::Node->new(1);
	my $node013 = CDS::Parser::Node->new(0);
	my $node014 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&transfer});
	$cds->addArrow($node000, 1, 0, 'thoroughly');
	$cds->addArrow($node001, 0, 0, 'leniently');
	$cds->addDefault($node003);
	$cds->addArrow($node003, 1, 0, 'leniently', \&collectLeniently);
	$cds->addArrow($node003, 1, 0, 'thoroughly', \&collectThoroughly);
	$help->addArrow($node002, 1, 0, 'transfer');
	$node000->addArrow($node003, 1, 0, 'leniently', \&collectLeniently1);
	$node001->addArrow($node003, 0, 0, 'thoroughly', \&collectLeniently1);
	$node003->addArrow($node004, 1, 0, 'transfer');
	$node004->addDefault($node005);
	$node004->addDefault($node006);
	$node004->addArrow($node007, 1, 0, 'account', \&collectAccount);
	$node004->addArrow($node007, 1, 0, 'tree', \&collectTree);
	$node005->addArrow($node005, 1, 0, 'OBJECT', \&collectObject);
	$node005->addArrow($node012, 1, 0, 'OBJECT', \&collectObject);
	$node006->addArrow($node006, 1, 0, 'ACCOUNT', \&collectAccount1);
	$node006->addArrow($node012, 1, 0, 'ACCOUNT', \&collectAccount1);
	$node007->addDefault($node008);
	$node007->addDefault($node009);
	$node008->addArrow($node008, 1, 0, 'HASH', \&collectHash);
	$node008->addArrow($node012, 1, 0, 'HASH', \&collectHash);
	$node009->addArrow($node009, 1, 0, 'HASH', \&collectHash);
	$node009->addArrow($node010, 1, 0, 'HASH', \&collectHash);
	$node010->addArrow($node011, 1, 0, 'from');
	$node011->addArrow($node012, 1, 0, 'STORE', \&collectStore);
	$node012->addArrow($node013, 1, 0, 'to');
	$node013->addArrow($node013, 1, 0, 'STORE', \&collectStore1);
	$node013->addArrow($node014, 1, 0, 'STORE', \&collectStore1);
}

sub collectAccount($o, $label, $value) {
	$o:type = 'account';
}

sub collectAccount1($o, $label, $value) {
	push @$o:accountTokens, $value;
	$o:type = 'account';
}

sub collectHash($o, $label, $value) {
	push @$o:hashes, $value;
}

sub collectLeniently($o, $label, $value) {
	$o:leniently = 1;
}

sub collectLeniently1($o, $label, $value) {
	$o:leniently = 1;
	$o:thoroughly = 1;
}

sub collectObject($o, $label, $value) {
	push @$o:objectTokens, $value;
	$o:type = 'tree';
}

sub collectStore($o, $label, $value) {
	$o:fromStore = $value;
}

sub collectStore1($o, $label, $value) {
	push @$o:toStores, $value;
}

sub collectThoroughly($o, $label, $value) {
	$o:thoroughly = 1;
}

sub collectTree($o, $label, $value) {
	$o:type = 'tree';
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# HTML FOLDER NAME transfer
# HTML TITLE Transfer
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds transfer ACCOUNT* to STORE*');
	$ui->command('cds transfer account HASH* from STORE to STORE*');
	$ui->p('Copies an account including all referenced trees from one store to another.');
	$ui->space;
	$ui->command('cds transfer OBJECT* to STORE*');
	$ui->command('cds transfer tree HASH* from STORE to STORE*');
	$ui->p('Copies a tree from one store to another.');
	$ui->space;
	$ui->command('cds transfer account HASH* to STORE*');
	$ui->command('cds transfer tree HASH* to STORE*');
	$ui->p('As above, but uses the selected store as source store.');
	$ui->space;
	$ui->command('cds ', $ui->underlined('leniently'), ' transfer …');
	$ui->p('Warns about missing objects, but ignores them and proceeds with the rest.');
	$ui->space;
	$ui->command('cds ', $ui->underlined('thoroughly'), ' transfer …');
	$ui->p('Check subtrees of objects existing at the destination. This may be used to fix missing objects on the destination store.');
	$ui->space;
}

sub transfer($o, $cmd) {
	# Collect the arguments
	$o:keyPairToken = $o:actor->preferredKeyPairToken;
	$o:accountTokens = [];
	$o:objectTokens = [];
	$o:hashes = [];
	$o:toStores = [];
	$cmd->collect($o);

	# Use the selected store
	$o:fromStore = $o:actor->preferredStore if scalar @$o:hashes && ! $o:fromStore;

	# Prepare the accounts and objects
	if ($o:type eq 'tree') {
		for my $hash (@$o:hashes) {
			push @$o:objectTokens, CDS::ObjectToken->new($o:fromStore, $hash);
		}
	} else {
		for my $hash (@$o:hashes) {
			push @$o:accountTokens, CDS::ObjectToken->new($o:fromStore, $hash);
		}
	}

	# Copy the public key of every account first
	for my $accountToken (@$o:accountTokens) {
		push @$o:objectTokens, CDS::ObjectToken->new($accountToken->cliStore, $accountToken->hash);
	}

	# Prepare the destination stores
	my $toStores = [];
	for my $toStore (@$o:toStores) {
		push @$toStores, {store => $toStore, storeError => undef, needed => [1]};
	}

	# Print the stores
	$o:ui->space;
	my $n = scalar @$toStores;
	for my $i (0 .. $n - 1) {
		my $toStore = $toStores->[$i];
		$o:ui->line($o:ui->gray(' │' x $i, ' ┌', '──' x ($n - $i), ' ', $toStore:store->url));
	}

	# Process all trees
	$o:objects = {};
	$o:missingObjects = {};
	for my $objectToken (@$o:objectTokens) {
		$o:ui->line($o:ui->gray(' │' x $n));
		$o->process($objectToken->hash, $objectToken->cliStore, $toStores, 1);
	}

	# Process all accounts
	my $keyPair = $o:keyPairToken->keyPair;
	for my $accountToken (@$o:accountTokens) {
		for my $boxLabel ('public', 'private', 'messages') {
			$o:ui->line($o:ui->gray(' │' x $n));
			$o:ui->line($o:ui->gray(' │' x $n, ' Transferring ', $boxLabel, ' box of ', $accountToken->hash->hex));
			my ($hashes, $listError) = $accountToken->cliStore->list($accountToken->hash, $boxLabel, 0, $keyPair);
			next if $listError;

			for my $hash (@$hashes) {
				$o->process($hash, $accountToken->cliStore, $toStores, 1) // next;

				for my $toStore (@$toStores) {
					next if defined $toStore:storeError;
					$toStore:storeError = $toStore:store->add($accountToken->hash, $boxLabel, $hash, $keyPair);
				}
			}
		}
	}

	# Print the stores again, with their errors
	$o:ui->line($o:ui->gray(' │' x $n));
	for my $i (reverse 0 .. $n - 1) {
		my $toStore = $toStores->[$i];
		$o:ui->line($o:ui->gray(' │' x $i, ' └', '──' x ($n - $i), ' ', $toStore:store->url), ' ', defined $toStore:storeError ? $o:ui->red($toStore:storeError) : '');
	}

	# Report the total size
	my $totalSize = 0;
	my $totalDataSize = 0;
	map { $totalSize += $_:size ; $totalDataSize += $_:dataSize } values %$o:objects;
	$o:ui->space;
	$o:ui->p(scalar keys %$o:objects, ' unique objects ', $o:ui->bold($o:ui->niceFileSize($totalSize)), ' ', $o:ui->gray($o:ui->niceFileSize($totalDataSize), ' data'));
	$o:ui->pOrange(scalar keys %$o:missingObjects, ' or more objects are missing') if scalar keys %$o:missingObjects;
	$o:ui->space;
}

sub process($o, $hash, $fromStore, $toStores, $depth) {
	my $hashHex = $hash->hex;
	my $keyPair = $o:keyPairToken->keyPair;

	# Check if we retrieved this object before
	if (exists $o:objects->{$hashHex}) {
		$o->report($hash->hex, $toStores, $depth, $o:ui->green('copied before'));
		return 1;
	}

	# Try to book the object on all active stores
	my $countNeeded = 0;
	my $hasActiveStore = 0;
	for my $toStore (@$toStores) {
		next if defined $toStore:storeError;
		$hasActiveStore = 1;
		next if ! $o:thoroughly && ! $toStore:needed->[$depth - 1];

		my ($found, $bookError) = $toStore:store->book($hash);
		if (defined $bookError) {
			$toStore:storeError = $bookError;
			next;
		}

		next if $found;
		$toStore:needed->[$depth] = 1;
		$countNeeded += 1;
	}

	# Return if all stores reported an error
	return if ! $hasActiveStore;

	# Ignore existing subtrees at the destination unless "thoroughly" is set
	if (! $o:thoroughly && ! $countNeeded) {
		$o->report($hashHex, $toStores, $depth, $o:ui->gray('skipping subtree'));
		return 1;
	}

	# Retrieve the object
	my ($object, $getError) = $fromStore->get($hash, $keyPair);
	return if defined $getError;

	if (! defined $object) {
		$o:missingObjects->{$hashHex} = 1;
		$o->report($hashHex, $toStores, $depth, $o:ui->orange('is missing'));
		return if ! $o:leniently;
	}

	# Display
	my $size = $object->byteLength;
	$o:objects->{$hashHex} = {needed => $countNeeded, size => $size, dataSize => length $object->data};
	$o->report($hashHex, $toStores, $depth, $o:ui->bold($o:ui->niceFileSize($size)), ' ', $o:ui->gray($object->hashesCount, ' hashes'));

	# Process all children
	foreach my $hash ($object->hashes) {
		$o->process($hash, $fromStore, $toStores, $depth + 1) // return;
	}

	# Write the object to all active stores
	for my $toStore (@$toStores) {
		next if defined $toStore:storeError;
		next if ! $toStore:needed->[$depth];
		my $putError = $toStore:store->put($hash, $object, $keyPair);
		$toStore:storeError = $putError if $putError;
	}

	return 1;
}

sub report($o, $hashHex, $toStores, $depth; @message) {
	my @text;
	for my $toStore (@$toStores) {
		if ($toStore:storeError) {
			push @text, $o:ui->red(' ⨯');
		} elsif ($toStore:needed->[$depth]) {
			push @text, $o:ui->green(' +');
		} else {
			push @text, $o:ui->green(' ‒');
		}
	}

	push @text, ' ', '  ' x ($depth - 1), $hashHex;
	push @text, ' ', @_;
	$o:ui->line(@text);
}
