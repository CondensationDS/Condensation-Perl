use Encode;
use Fcntl;

# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0);
	my $node001 = CDS::Parser::Node->new(0);
	my $node002 = CDS::Parser::Node->new(0);
	my $node003 = CDS::Parser::Node->new(0);
	my $node004 = CDS::Parser::Node->new(0);
	my $node005 = CDS::Parser::Node->new(0);
	my $node006 = CDS::Parser::Node->new(0);
	my $node007 = CDS::Parser::Node->new(0);
	my $node008 = CDS::Parser::Node->new(0);
	my $node009 = CDS::Parser::Node->new(0);
	my $node010 = CDS::Parser::Node->new(0);
	my $node011 = CDS::Parser::Node->new(0);
	my $node012 = CDS::Parser::Node->new(0);
	my $node013 = CDS::Parser::Node->new(0);
	my $node014 = CDS::Parser::Node->new(0);
	my $node015 = CDS::Parser::Node->new(0);
	my $node016 = CDS::Parser::Node->new(0);
	my $node017 = CDS::Parser::Node->new(0);
	my $node018 = CDS::Parser::Node->new(0);
	my $node019 = CDS::Parser::Node->new(0);
	my $node020 = CDS::Parser::Node->new(0);
	my $node021 = CDS::Parser::Node->new(0);
	my $node022 = CDS::Parser::Node->new(0);
	my $node023 = CDS::Parser::Node->new(0);
	my $node024 = CDS::Parser::Node->new(0);
	my $node025 = CDS::Parser::Node->new(1);
	my $node026 = CDS::Parser::Node->new(0);
	my $node027 = CDS::Parser::Node->new(0);
	my $node028 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node029 = CDS::Parser::Node->new(1);
	my $node030 = CDS::Parser::Node->new(0);
	my $node031 = CDS::Parser::Node->new(0);
	my $node032 = CDS::Parser::Node->new(0);
	my $node033 = CDS::Parser::Node->new(0);
	my $node034 = CDS::Parser::Node->new(0);
	my $node035 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&checkPermissions});
	my $node036 = CDS::Parser::Node->new(0);
	my $node037 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&fixPermissions});
	my $node038 = CDS::Parser::Node->new(0);
	my $node039 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&showPermissions});
	my $node040 = CDS::Parser::Node->new(0);
	my $node041 = CDS::Parser::Node->new(1);
	my $node042 = CDS::Parser::Node->new(0);
	my $node043 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&addAccount});
	my $node044 = CDS::Parser::Node->new(0);
	my $node045 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&removeAccount});
	my $node046 = CDS::Parser::Node->new(0);
	my $node047 = CDS::Parser::Node->new(1);
	my $node048 = CDS::Parser::Node->new(0);
	my $node049 = CDS::Parser::Node->new(0);
	my $node050 = CDS::Parser::Node->new(0);
	my $node051 = CDS::Parser::Node->new(0);
	my $node052 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&checkPermissions});
	my $node053 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&fixPermissions});
	my $node054 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&showPermissions});
	my $node055 = CDS::Parser::Node->new(1);
	my $node056 = CDS::Parser::Node->new(0);
	my $node057 = CDS::Parser::Node->new(0);
	my $node058 = CDS::Parser::Node->new(0);
	my $node059 = CDS::Parser::Node->new(0);
	my $node060 = CDS::Parser::Node->new(0);
	my $node061 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&addAccount});
	my $node062 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&removeAccount});
	my $node063 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&setPermissions});
	my $node064 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&createStore});
	$cds->addArrow($node001, 1, 0, 'create');
	$cds->addArrow($node003, 1, 0, 'check');
	$cds->addArrow($node004, 1, 0, 'fix');
	$cds->addArrow($node005, 1, 0, 'show');
	$cds->addArrow($node007, 1, 0, 'set');
	$cds->addArrow($node009, 1, 0, 'add');
	$cds->addArrow($node010, 1, 0, 'add');
	$cds->addArrow($node011, 1, 0, 'add');
	$cds->addArrow($node012, 1, 0, 'add');
	$cds->addArrow($node013, 1, 0, 'add');
	$cds->addArrow($node023, 1, 0, 'remove');
	$help->addArrow($node000, 1, 0, 'create');
	$node000->addArrow($node028, 1, 0, 'store');
	$node001->addArrow($node002, 1, 0, 'store');
	$node002->addArrow($node029, 1, 0, 'FOLDERNAME', \&collectFoldername);
	$node003->addArrow($node035, 1, 0, 'permissions');
	$node004->addArrow($node037, 1, 0, 'permissions');
	$node005->addArrow($node006, 1, 0, 'permission');
	$node006->addArrow($node039, 1, 0, 'scheme');
	$node007->addArrow($node008, 1, 0, 'permission');
	$node008->addArrow($node041, 1, 0, 'scheme');
	$node009->addArrow($node014, 1, 0, 'account');
	$node010->addArrow($node015, 1, 0, 'account');
	$node011->addArrow($node016, 1, 0, 'account');
	$node012->addArrow($node017, 1, 0, 'account');
	$node013->addArrow($node018, 1, 0, 'account');
	$node014->addArrow($node019, 1, 0, 'for');
	$node015->addArrow($node020, 1, 0, 'for');
	$node016->addArrow($node021, 1, 0, 'for');
	$node017->addArrow($node043, 1, 1, 'ACCOUNT', \&collectAccount);
	$node018->addArrow($node022, 1, 0, 'for');
	$node019->addArrow($node043, 1, 0, 'OBJECTFILE', \&collectObjectfile);
	$node020->addArrow($node043, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node021->addArrow($node025, 1, 0, 'ACTOR', \&collectActor);
	$node022->addArrow($node043, 1, 0, 'OBJECT', \&collectObject);
	$node023->addArrow($node024, 1, 0, 'account');
	$node024->addArrow($node045, 1, 0, 'HASH', \&collectHash);
	$node025->addArrow($node026, 1, 0, 'on');
	$node025->addArrow($node027, 0, 0, 'from');
	$node026->addArrow($node043, 1, 0, 'STORE', \&collectStore);
	$node027->addArrow($node043, 0, 0, 'STORE', \&collectStore);
	$node029->addArrow($node030, 1, 0, 'for');
	$node029->addArrow($node031, 1, 0, 'for');
	$node029->addArrow($node032, 1, 0, 'for');
	$node029->addDefault($node047);
	$node030->addArrow($node033, 1, 0, 'user');
	$node031->addArrow($node034, 1, 0, 'group');
	$node032->addArrow($node047, 1, 0, 'everybody', \&collectEverybody);
	$node033->addArrow($node047, 1, 0, 'USER', \&collectUser);
	$node034->addArrow($node047, 1, 0, 'GROUP', \&collectGroup);
	$node035->addArrow($node036, 1, 0, 'of');
	$node036->addArrow($node052, 1, 0, 'STORE', \&collectStore1);
	$node037->addArrow($node038, 1, 0, 'of');
	$node038->addArrow($node053, 1, 0, 'STORE', \&collectStore1);
	$node039->addArrow($node040, 1, 0, 'of');
	$node040->addArrow($node054, 1, 0, 'STORE', \&collectStore1);
	$node041->addArrow($node042, 1, 0, 'of');
	$node041->addDefault($node055);
	$node042->addArrow($node055, 1, 0, 'STORE', \&collectStore1);
	$node043->addArrow($node044, 1, 0, 'to');
	$node044->addArrow($node061, 1, 0, 'STORE', \&collectStore1);
	$node045->addArrow($node046, 1, 0, 'from');
	$node046->addArrow($node062, 1, 0, 'STORE', \&collectStore1);
	$node047->addArrow($node048, 1, 0, 'and');
	$node047->addDefault($node064);
	$node048->addArrow($node049, 1, 0, 'remember');
	$node049->addArrow($node050, 1, 0, 'it');
	$node050->addArrow($node051, 1, 0, 'as');
	$node051->addArrow($node064, 1, 0, 'TEXT', \&collectText);
	$node055->addArrow($node056, 1, 0, 'to');
	$node055->addArrow($node057, 1, 0, 'to');
	$node055->addArrow($node058, 1, 0, 'to');
	$node056->addArrow($node059, 1, 0, 'user');
	$node057->addArrow($node060, 1, 0, 'group');
	$node058->addArrow($node063, 1, 0, 'everybody', \&collectEverybody);
	$node059->addArrow($node063, 1, 0, 'USER', \&collectUser);
	$node060->addArrow($node063, 1, 0, 'GROUP', \&collectGroup);
}

sub collectAccount($o, $label, $value) {
	$o:accountToken = $value;
}

sub collectActor($o, $label, $value) {
	$o:actorHash = $value;
}

sub collectEverybody($o, $label, $value) {
	$o:permissions = CDS::FolderStore::PosixPermissions::World->new;
}

sub collectFoldername($o, $label, $value) {
	$o:foldername = $value;
}

sub collectGroup($o, $label, $value) {
	$o:permissions = CDS::FolderStore::PosixPermissions::Group->new($o:group);
}

sub collectHash($o, $label, $value) {
	$o:hash = $value;
}

sub collectKeypair($o, $label, $value) {
	$o:keyPairToken = $value;
}

sub collectObject($o, $label, $value) {
	$o:accountToken = CDS::AccountToken->new($value->cliStore, $value->hash);
}

sub collectObjectfile($o, $label, $value) {
	$o:file = $value;
}

sub collectStore($o, $label, $value) {
	$o:accountToken = CDS::AccountToken->new($value, $o:actorHash);
}

sub collectStore1($o, $label, $value) {
	$o:store = $value;
}

sub collectText($o, $label, $value) {
	$o:label = $value;
}

sub collectUser($o, $label, $value) {
	$o:permissions = CDS::FolderStore::PosixPermissions::User->new($value);
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# INCLUDE FolderStore/CheckLogger.pm
# INCLUDE FolderStore/FixLogger.pm
# INCLUDE FolderStore/Logger.pm
# INCLUDE FolderStore/SetLogger.pm

# HTML FOLDER NAME folder-store
# HTML TITLE Folder store management
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds create store FOLDERNAME');
	$ui->p('Creates a new store in FOLDERNAME, and adds it to the list of known stores. If the folder does not exist, it is created. If it does exist, it must be empty.');
	$ui->space;
	$ui->p('By default, the filesystem permissions of the store are set such that only the current user can post objects and modify boxes. Other users on the system can post to the message box, list boxes, and read objects.');
	$ui->space;
	$ui->command('… for user USER');
	$ui->p('Makes the store accessible to the user USER.');
	$ui->space;
	$ui->command('… for group GROUP');
	$ui->p('Makes the store accessible to the group GROUP.');
	$ui->space;
	$ui->command('… for everybody');
	$ui->p('Makes the store accessible to everybody.');
	$ui->space;
	$ui->p('Note that the permissions only affect direct filesystem access. If your store is exposed by a server (e.g. a web server), it may be accessible to others.');
	$ui->space;
	$ui->command('… and remember it as TEXT');
	$ui->p('Remembers the store under the label TEXT. See "cds help remember" for details.');
	$ui->space;
	$ui->command('cds check permissions [of STORE]');
	$ui->p('Checks the permissions (owner, mode) of all accounts, boxes, box entries, and objects of the store, and reports any error. The permission scheme (user, group, or everybody) is derived from the "accounts" and "objects" folders.');
	$ui->p('If the store is omitted, the selected store is used.');
	$ui->space;
	$ui->command('cds fix permissions [of STORE]');
	$ui->p('Same as above, but tries to fix the permissions (chown, chmod) instead of just reporting them.');
	$ui->space;
	$ui->command('cds show permission scheme [of STORE]');
	$ui->p('Reports the permission scheme of the store.');
	$ui->space;
	$ui->command('cds set permission scheme [of STORE] to (user USER|group GROUP|everybody)');
	$ui->p('Sets the permission scheme of the stores, and changes all permissions accordingly.');
	$ui->space;
	$ui->command('cds add account ACCOUNT [to STORE]');
	$ui->command('cds add account for FILE [to STORE]');
	$ui->command('cds add account for KEYPAIR [to STORE]');
	$ui->command('cds add account for OBJECT [to STORE]');
	$ui->command('cds add account for ACTOR on STORE [to STORE]');
	$ui->p('Uploads the public key (FILE, KEYPAIR, OBJECT, ACCOUNT, or ACTOR on STORE) onto the store, and adds the corresponding account. This grants the user the right to access this account.');
	$ui->space;
	$ui->command('cds remove account HASH [from STORE]');
	$ui->p('Removes the indicated account from the store. This immediately destroys the user\'s data.');
	$ui->space;
}

sub createStore($o, $cmd) {
	$o:permissions = CDS::FolderStore::PosixPermissions::User->new;
	$cmd->collect($o);

	# Give up if the folder is non-empty (but we accept hidden files)
	for my $file (CDS->listFolder($o:foldername)) {
		next if $file =~ /^\./;
		$o:ui->pRed('The folder ', $o:foldername, ' is not empty. Giving up …');
		return;
	}

	# Create the object store
	$o->create($o:foldername.'/objects') // return;
	$o:ui->pGreen('Object store created for ', $o:permissions->target, '.');

	# Create the account store
	$o->create($o:foldername.'/accounts') // return;
	$o:ui->pGreen('Account store created for ', $o:permissions->target, '.');

	# Return if the user does not want us to add the store
	return if ! defined $o:label;

	# Remember the store
	my $record = CDS::Record->new;
	$record->addText('store')->addText('file://'.$o:foldername);
	$o:actor->remember($o:label, $record);
	$o:actor->saveOrShowError;
}

# Creates a folder with the selected permissions.
sub create($o, $folder) {
	# Create the folders to here if necessary
	for my $intermediateFolder (CDS->intermediateFolders($folder)) {
		mkdir $intermediateFolder, 0755;
	}

	# mkdir (if it does not exist yet) and chmod (if it does exist already)
	mkdir $folder, $o:permissions->baseFolderMode;
	chmod $o:permissions->baseFolderMode, $folder;
	chown $o:permissions->uid // -1, $o:permissions->gid // -1, $folder;

	# Check if the result is correct
	my @s = stat $folder;
	return $o:ui->error('Unable to create ', $o:foldername, '.') if ! scalar @s;
	my $mode = $s[2];
	return $o:ui->error($folder, ' exists, but is not a folder') if ! Fcntl::S_ISDIR($mode);
	return $o:ui->error('Unable to set the owning user ', $o:permissions->user, ' for ', $folder, '.') if defined $o:permissions->uid && $s[4] != $o:permissions->uid;
	return $o:ui->error('Unable to set the owning group ', $o:permissions->group, ' for ', $folder, '.') if defined $o:permissions->gid && $s[5] != $o:permissions->gid;
	return $o:ui->error('Unable to set the mode on ', $folder, '.') if ($mode & 0777) != $o:permissions->baseFolderMode;
	return 1;
}

sub existingFolderStoreOrShowError($o) {
	my $store = $o:store // $o:actor->preferredStore;

	my $folderStore = CDS::FolderStore->forUrl($store->url);
	if (! $folderStore) {
		$o:ui->error('"', $store->url, '" is not a folder store.');
		$o:ui->space;
		$o:ui->p('Account management and file system permission checks only apply to stores on the local file system. Such stores are referred to by file://… URLs, or file system paths.');
		$o:ui->p('To fix the permissions on a remote store, log onto that server and fix the permissions there. Note that permissions are not part of the Condensation protocol, but a property of some underlying storage systems, such as file systems.');
		$o:ui->space;
		return;
	}

	if (! $folderStore->exists) {
		$o:ui->error('"', $folderStore->folder, '" does not exist.');
		$o:ui->space;
		$o:ui->p('The folder either does not exist, or is not a folder store. You can create this store using:');
		$o:ui->line($o:ui->gold('  cds create store ', $folderStore->folder));
		$o:ui->space;
		return;
	}

	return $folderStore;
}

sub showPermissions($o, $cmd) {
	$cmd->collect($o);
	my $folderStore = $o->existingFolderStoreOrShowError // return;
	$o->showStore($folderStore);
	$o:ui->space;
}

sub showStore($o, $folderStore) {
	$o:ui->space;
	$o:ui->title('Store');
	$o:ui->line($folderStore->folder);
	$o:ui->line('Accessible to ', $folderStore->permissions->target, '.');
}

sub setPermissions($o, $cmd) {
	$cmd->collect($o);

	my $folderStore = $o->existingFolderStoreOrShowError // return;
	$o->showStore($folderStore);

	$folderStore->setPermissions($o:permissions);
	$o:ui->line('Changing permissions …');
	my $logger = CDS::Commands::FolderStore::SetLogger->new($o, $folderStore->folder);
	$folderStore->checkPermissions($logger) || $o->traversalFailed($folderStore);
	$logger->summary;

	$o:ui->space;
}

sub checkPermissions($o, $cmd) {
	$cmd->collect($o);

	my $folderStore = $o->existingFolderStoreOrShowError // return;
	$o->showStore($folderStore);

	$o:ui->line('Checking permissions …');
	my $logger = CDS::Commands::FolderStore::CheckLogger->new($o, $folderStore->folder);
	$folderStore->checkPermissions($logger) || $o->traversalFailed($folderStore);
	$logger->summary;

	$o:ui->space;
}

sub fixPermissions($o, $cmd) {
	$cmd->collect($o);

	my $folderStore = $o->existingFolderStoreOrShowError // return;
	$o->showStore($folderStore);

	$o:ui->line('Fixing permissions …');
	my $logger = CDS::Commands::FolderStore::FixLogger->new($o, $folderStore->folder);
	$folderStore->checkPermissions($logger) || $o->traversalFailed($folderStore);
	$logger->summary;

	$o:ui->space;
}

sub traversalFailed($o, $folderStore) {
	$o:ui->space;
	$o:ui->p('Traversal failed because a file or folder could not be accessed. You may have to fix the permissions manually, or run this command with other privileges.');
	$o:ui->p('If you have root privileges, you can take over this store using:');
	my $userName = getpwuid($<);
	my $groupName = getgrgid($();
	$o:ui->line($o:ui->gold('  sudo chown -R ', $userName, ':', $groupName, ' ', $folderStore->folder));
	$o:ui->p('and then set the desired permission scheme:');
	$o:ui->line($o:ui->gold('  cds set permissions of ', $folderStore->folder, ' to …'));
	$o:ui->space;
	exit(1);
}

sub addAccount($o, $cmd) {
	$cmd->collect($o);

	# Prepare
	my $folderStore = $o->existingFolderStoreOrShowError // return;
	my $publicKey = $o->publicKey // return;

	# Upload the public key onto the store
	my $error = $folderStore->put($publicKey->hash, $publicKey->object);
	return $o:ui->error('Unable to upload the public key: ', $error) if $error;

	# Create the account folder
	my $folder = $folderStore->folder.'/accounts/'.$publicKey->hash->hex;
	my $permissions = $folderStore->permissions;
	$permissions->mkdir($folder, $permissions->accountFolderMode);
	return $o:ui->error('Unable to create folder "', $folder, '".') if ! -d $folder;
	$o:ui->pGreen('Account ', $publicKey->hash->hex, ' added.');
	return 1;
}

sub publicKey($o) {
	return $o:keyPairToken->keyPair->publicKey if $o:keyPairToken;

	if ($o:file) {
		my $bytes = CDS->readBytesFromFile($o:file) // return $o:ui->error('Cannot read "', $o:file, '".');
		my $object = CDS::Object->fromBytes($bytes) // return $o:ui->error('"', $o:file, '" is not a public key.');
		return CDS::PublicKey->fromObject($object) // return $o:ui->error('"', $o:file, '" is not a public key.');
	}

	return $o:actor->uiGetPublicKey($o:accountToken->actorHash, $o:accountToken->cliStore, $o:actor->preferredKeyPairToken);
}

sub removeAccount($o, $cmd) {
	$cmd->collect($o);

	# Prepare the folder
	my $folderStore = $o->existingFolderStoreOrShowError // return;
	my $folder = $folderStore->folder.'/accounts/'.$o:hash->hex;
	my $deletedFolder = $folderStore->folder.'/accounts/deleted-'.$o:hash->hex;

	# Rename, so that it is not visible any more
	$o->recursivelyDelete($deletedFolder) if -e $deletedFolder;
	return $o:ui->line('The account ', $o:hash->hex, ' does not exist.') if ! -e $folder;
	rename($folder, $deletedFolder) || return $o:ui->error('Unable to rename the folder "', $folder, '".');

	# Try to delete it entirely
	$o->recursivelyDelete($deletedFolder);
	$o:ui->pGreen('Account ', $o:hash->hex, ' removed.');
	return 1;
}

sub recursivelyDelete($o, $folder) {
	for my $filename (CDS->listFolder($folder)) {
		next if $filename =~ /^\./;
		my $file = $folder.'/'.$filename;
		if (-f $file) {
			unlink $file || $o:ui->pOrange('Unable to remove the file "', $file, '".');
		} elsif (-d $file) {
			$o->recursivelyDelete($file);
		}
	}

	rmdir($folder) || $o:ui->pOrange('Unable to remove the folder "', $folder, '".');
}
