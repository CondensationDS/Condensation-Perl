# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0);
	my $node001 = CDS::Parser::Node->new(0);
	my $node002 = CDS::Parser::Node->new(0);
	my $node003 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node004 = CDS::Parser::Node->new(0);
	my $node005 = CDS::Parser::Node->new(0);
	my $node006 = CDS::Parser::Node->new(0);
	my $node007 = CDS::Parser::Node->new(0);
	my $node008 = CDS::Parser::Node->new(0);
	my $node009 = CDS::Parser::Node->new(0);
	my $node010 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&showTree});
	$cds->addArrow($node001, 1, 0, 'show');
	$cds->addArrow($node002, 0, 0, 'show');
	$help->addArrow($node000, 1, 0, 'show');
	$node000->addArrow($node003, 1, 0, 'tree');
	$node001->addArrow($node004, 1, 0, 'tree');
	$node002->addArrow($node004, 0, 0, 'trees');
	$node004->addDefault($node005);
	$node004->addDefault($node006);
	$node004->addDefault($node007);
	$node005->addArrow($node005, 1, 0, 'HASH', \&collectHash);
	$node005->addArrow($node010, 1, 0, 'HASH', \&collectHash);
	$node006->addArrow($node006, 1, 0, 'HASH', \&collectHash);
	$node006->addArrow($node008, 1, 0, 'HASH', \&collectHash);
	$node007->addArrow($node007, 1, 0, 'OBJECT', \&collectObject);
	$node007->addArrow($node010, 1, 0, 'OBJECT', \&collectObject);
	$node008->addArrow($node009, 1, 0, 'on');
	$node009->addArrow($node010, 1, 0, 'STORE', \&collectStore);
}

sub collectHash($o, $label, $value) {
	push @$o:hashes, $value;
}

sub collectObject($o, $label, $value) {
	push @$o:objectTokens, $value;
}

sub collectStore($o, $label, $value) {
	$o:store = $value;
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# HTML FOLDER NAME show-tree
# HTML TITLE Show trees
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds show tree OBJECT*');
	$ui->command('cds show tree HASH* on STORE');
	$ui->p('Downloads a tree, and shows the tree hierarchy. If an object has been traversed before, it is listed as "reported above".');
	$ui->space;
	$ui->command('cds show tree HASH*');
	$ui->p('As above, but uses the selected store.');
	$ui->space;
}

sub showTree($o, $cmd) {
	$o:keyPairToken = $o:actor->preferredKeyPairToken;
	$o:objectTokens = [];
	$o:hashes = [];
	$cmd->collect($o);

	# Process all trees
	for my $objectToken (@$o:objectTokens) {
		$o:ui->space;
		$o->process($objectToken->hash, $objectToken->cliStore);
	}

	if (scalar @$o:hashes) {
		my $store = $o:store // $o:actor->preferredStore;
		for my $hash (@$o:hashes) {
			$o:ui->space;
			$o->process($hash, $store);
		}
	}

	# Report the total size
	my $totalSize = 0;
	my $totalDataSize = 0;
	map { $totalSize += $_:size ; $totalDataSize += $_:dataSize } values %$o:objects;
	$o:ui->space;
	$o:ui->p(scalar keys %$o:objects, ' unique objects ', $o:ui->bold($o:ui->niceFileSize($totalSize)), $o:ui->gray(' (', $o:ui->niceFileSize($totalSize - $totalDataSize), ' header and ', $o:ui->niceFileSize($totalDataSize), ' data)'));
	$o:ui->pRed(scalar keys %$o:missingObjects, ' or more objects are missing') if scalar keys %$o:missingObjects;
	$o:ui->space;
}

sub process($o, $hash, $store) {
	my $hashHex = $hash->hex;

	# Check if we retrieved this object before
	if (exists $o:objects->{$hashHex}) {
		$o:ui->line($hash->hex, ' reported above') ;
		return 1;
	}

	# Retrieve the object
	my ($object, $storeError) = $store->get($hash, $o:keyPairToken->keyPair);
	return if defined $storeError;

	if (! $object) {
		$o:missingObjects->{$hashHex} = 1;
		return $o:ui->line($hashHex, ' ', $o:ui->red('is missing'));
	}

	# Display
	my $size = $object->byteLength;
	$o:objects->{$hashHex} = {size => $size, dataSize => length $object->data};
	$o:ui->line($hashHex, ' ', $o:ui->bold($o:ui->niceFileSize($size)), ' ', $o:ui->gray($object->hashesCount, ' hashes'));

	# Process all children
	$o:ui->pushIndent;
	foreach my $hash ($object->hashes) {
		$o->process($hash, $store) // return;
	}
	$o:ui->popIndent;
	return 1;
}
