# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0);
	my $node001 = CDS::Parser::Node->new(0);
	my $node002 = CDS::Parser::Node->new(0);
	my $node003 = CDS::Parser::Node->new(0);
	my $node004 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node005 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&showMyCard});
	my $node006 = CDS::Parser::Node->new(1);
	my $node007 = CDS::Parser::Node->new(0);
	my $node008 = CDS::Parser::Node->new(0);
	my $node009 = CDS::Parser::Node->new(0);
	my $node010 = CDS::Parser::Node->new(0);
	my $node011 = CDS::Parser::Node->new(0);
	my $node012 = CDS::Parser::Node->new(0);
	my $node013 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&showCard});
	$cds->addArrow($node001, 1, 0, 'show');
	$cds->addArrow($node002, 1, 0, 'show');
	$help->addArrow($node000, 1, 0, 'show');
	$node000->addArrow($node004, 1, 0, 'card');
	$node001->addArrow($node006, 1, 0, 'card');
	$node002->addArrow($node003, 1, 0, 'my');
	$node003->addArrow($node005, 1, 0, 'card');
	$node006->addArrow($node007, 1, 0, 'of');
	$node006->addArrow($node008, 1, 0, 'of');
	$node006->addArrow($node009, 1, 0, 'of');
	$node006->addArrow($node010, 1, 0, 'of');
	$node006->addDefault($node011);
	$node007->addArrow($node007, 1, 0, 'ACCOUNT', \&collectAccount);
	$node007->addArrow($node013, 1, 1, 'ACCOUNT', \&collectAccount);
	$node008->addArrow($node013, 1, 0, 'ACTORGROUP', \&collectActorgroup);
	$node009->addArrow($node011, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node010->addArrow($node011, 1, 0, 'ACTOR', \&collectActor);
	$node011->addArrow($node012, 1, 0, 'on');
	$node011->addDefault($node013);
	$node012->addArrow($node012, 1, 0, 'STORE', \&collectStore);
	$node012->addArrow($node013, 1, 0, 'STORE', \&collectStore);
}

sub collectAccount($o, $label, $value) {
	push @$o:accountTokens, $value;
}

sub collectActor($o, $label, $value) {
	$o:actorHash = $value;
}

sub collectActorgroup($o, $label, $value) {
	for my $member ($value->actorGroup->members) {
	my $actorOnStore = $member->actorOnStore;
	$o->addKnownPublicKey($actorOnStore->publicKey);
	push @$o:accountTokens, CDS::AccountToken->new($actorOnStore->store, $actorOnStore->publicKey->hash);
	}
}

sub collectKeypair($o, $label, $value) {
	$o:keyPairToken = $value;
	$o:actorHash = $value->keyPair->publicKey->hash;
}

sub collectStore($o, $label, $value) {
	push @$o:stores, $value;
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# HTML FOLDER NAME show-card
# HTML TITLE Show an actor's public card
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds show card of ACCOUNT');
	$ui->command('cds show card of ACTOR [on STORE]');
	$ui->command('cds show card of KEYPAIR [on STORE]');
	$ui->p('Shows the card(s) of an actor.');
	$ui->space;
	$ui->command('cds show card of ACTORGROUP');
	$ui->p('Shows all cards of an actor group.');
	$ui->space;
	$ui->command('cds show card');
	$ui->p('Shows the card of the selected actor on the selected store.');
	$ui->space;
	$ui->command('cds show my card');
	$ui->p('Shows your own card.');
	$ui->space;
	$ui->p('An actor usually has one card. If no cards are shown, the corresponding actor does not exist, is not using that store, or has not properly announced itself. Two cards may exist while the actor is updating its card. Such a state is temporary, but may exist for hours or days if the actor has intermittent network access. Three or more cards may point to an error in the way the actor updates his card, an error in the synchronization code (if the account is synchronized). Two or more cards may also occur naturally when stores are merged.');
	$ui->space;
	$ui->p('A peer consists of one or more actors, which all publish their own card. The cards are usually different, but should contain consistent information.');
	$ui->space;
	$ui->p('You can publish your own card (i.e. the card of your main key pair) using');
	$ui->p('  cds announce');
	$ui->space;
}

sub showCard($o, $cmd) {
	$o:keyPairToken = $o:actor->preferredKeyPairToken;
	$o:stores = [];
	$o:accountTokens = [];
	$o:knownPublicKeys = {};
	$cmd->collect($o);

	# Use actorHash/store
	if (! scalar @$o:accountTokens) {
		$o:actorHash = $o:actor->preferredActorHash if ! $o:actorHash;
		push @$o:stores, $o:actor->preferredStores if ! scalar @$o:stores;
		for my $store (@$o:stores) {
			push @$o:accountTokens, CDS::AccountToken->new($store, $o:actorHash);
		}
	}

	# Show the cards
	$o->addKnownPublicKey($o:keyPairToken->keyPair->publicKey);
	$o->addKnownPublicKey($o:actor->keyPair->publicKey);
	for my $accountToken (@$o:accountTokens) {
		$o->processAccount($accountToken);
	}

	$o:ui->space;
}

sub showMyCard($o, $cmd) {
	$o:keyPairToken = $o:actor->preferredKeyPairToken;
	$o->processAccount(CDS::AccountToken->new($o:actor->messagingStore, $o:actor->keyPair->publicKey->hash));
	$o->processAccount(CDS::AccountToken->new($o:actor->storageStore, $o:actor->keyPair->publicKey->hash)) if $o:actor->storageStore->url ne $o:actor->messagingStore->url;
	$o:ui->space;
}

sub processAccount($o, $accountToken) {
	$o:ui->space;

	# Query the store
	my $store = $accountToken->cliStore;
	my ($hashes, $storeError) = $store->list($accountToken->actorHash, 'public', 0);
	if (defined $storeError) {
		$o:ui->title('public box of ', $o:actor->blueAccountReference($accountToken));
		return;
	}

	# Print the result
	my $count = scalar @$hashes;
	$o:ui->title('public box of ', $o:actor->blueAccountReference($accountToken), '  ', $o:ui->blue($count == 0 ? 'no cards' : $count == 1 ? '1 card' : $count.' cards'));
	return if ! $count;

	foreach my $hash (sort { $a->bytes cmp $b->bytes } @$hashes) {
		$o->processEntry($accountToken, $hash);
	}
}

sub processEntry($o, $accountToken, $hash) {
	my $keyPair = $o:keyPairToken->keyPair;
	my $store = $accountToken->cliStore;
	my $storeReference = $o:actor->storeReference($store);

	# Open the envelope
	$o:ui->line($o:ui->gold('cds open envelope ', $hash->hex), $o:ui->gray(' from ', $accountToken->actorHash->hex, ' on ', $storeReference));

	my $envelope = $o:actor->uiGetRecord($hash, $accountToken->cliStore, $o:keyPairToken) // return;
	my $publicKey = $o->getPublicKey($accountToken) // $o:ui->pRed('The owner\'s public key is missing. Skipping signature verification.');
	my $cardHash = $envelope->child('content')->hashValue // $o:ui->pRed('Missing content hash.');
	return $o:ui->pRed('Invalid signature.') if $publicKey && $cardHash && ! CDS->verifyEnvelopeSignature($envelope, $publicKey, $cardHash);

	# Read and show the card
	return if ! $cardHash;
	$o:ui->line($o:ui->gold('cds show record ', $cardHash->hex), $o:ui->gray(' on ', $storeReference));
	my $card = $o:actor->uiGetRecord($cardHash, $accountToken->cliStore, $o:keyPairToken) // return;

	$o:ui->pushIndent;
	$o:ui->recordChildren($card, $storeReference);
	$o:ui->popIndent;
	return;
}

sub getPublicKey($o, $accountToken) {
	my $hash = $accountToken->actorHash;
	my $knownPublicKey = $o:knownPublicKeys->{$hash->bytes};
	return $knownPublicKey if $knownPublicKey;
	my $publicKey = $o:actor->uiGetPublicKey($hash, $accountToken->cliStore, $o:keyPairToken) // return;
	$o->addKnownPublicKey($publicKey);
	return $publicKey;
}

sub addKnownPublicKey($o, $publicKey) {
	$o:knownPublicKeys->{$publicKey->hash->bytes} = $publicKey;
}
