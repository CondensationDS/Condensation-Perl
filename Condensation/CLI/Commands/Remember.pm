use Encode;

# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0, {constructor => \&new, function => \&showLabels});
	my $node001 = CDS::Parser::Node->new(0);
	my $node002 = CDS::Parser::Node->new(0);
	my $node003 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node004 = CDS::Parser::Node->new(0);
	my $node005 = CDS::Parser::Node->new(0);
	my $node006 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&forget});
	my $node007 = CDS::Parser::Node->new(1);
	my $node008 = CDS::Parser::Node->new(0);
	my $node009 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&remember});
	$cds->addArrow($node000, 1, 0, 'remember');
	$cds->addArrow($node001, 1, 0, 'forget');
	$help->addArrow($node003, 1, 0, 'forget');
	$help->addArrow($node003, 1, 0, 'remember');
	$node000->addArrow($node004, 1, 0, 'ACTOR', \&collectActor);
	$node000->addArrow($node007, 1, 1, 'ACCOUNT', \&collectAccount);
	$node000->addArrow($node007, 1, 0, 'ACTOR', \&collectActor);
	$node000->addArrow($node007, 1, 0, 'KEYPAIR', \&collectKeypair);
	$node000->addArrow($node007, 1, 0, 'STORE', \&collectStore);
	$node001->addDefault($node002);
	$node002->addArrow($node002, 1, 0, 'LABEL', \&collectLabel);
	$node002->addArrow($node006, 1, 0, 'LABEL', \&collectLabel);
	$node004->addArrow($node005, 1, 0, 'on');
	$node005->addArrow($node007, 1, 0, 'STORE', \&collectStore);
	$node007->addArrow($node008, 1, 0, 'as');
	$node008->addArrow($node009, 1, 0, 'TEXT', \&collectText);
}

sub collectAccount($o, $label, $value) {
	$o:store = $value->cliStore;
	$o:actorHash = $value->actorHash;
}

sub collectActor($o, $label, $value) {
	$o:actorHash = $value;
}

sub collectKeypair($o, $label, $value) {
	$o:keyPairToken = $value;
}

sub collectLabel($o, $label, $value) {
	push @$o:forget, $value;
}

sub collectStore($o, $label, $value) {
	$o:store = $value;
}

sub collectText($o, $label, $value) {
	$o:label = $value;
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# HTML FOLDER NAME remember
# HTML TITLE Remember
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds remember');
	$ui->p('Shows all remembered values.');
	$ui->space;
	$ui->command('cds remember ACCOUNT|ACTOR|STORE|KEYPAIR as TEXT');
	$ui->command('cds remember ACTOR on STORE as TEXT');
	$ui->p('Remembers the indicated actor hash, account, store, or key pair as TEXT. This information is stored in the global state, and therefore persists until the name is deleted (cds forget â€¦) or redefined (cds remember â€¦).');
	$ui->space;
	$ui->p('Key pairs are stored as link (absolute path) to the key pair file, and specific to the device.');
	$ui->space;
	$ui->command('cds forget LABEL');
	$ui->p('Forgets the corresponding item.');
	$ui->space;
}

sub remember($o, $cmd) {
	$cmd->collect($o);

	my $record = CDS::Record->new;
	$record->add('store')->addText($o:store->url) if defined $o:store;
	$record->add('actor')->add($o:actorHash->bytes) if defined $o:actorHash;
	$record->add('key pair')->addText($o:keyPairToken->file) if defined $o:keyPairToken;
	$o:actor->remember($o:label, $record);
	$o:actor->saveOrShowError;
}

sub forget($o, $cmd) {
	$o:forget = [];
	$cmd->collect($o);

	for my $label (@$o:forget) {
		$o:actor->groupRoot->child('labels')->child($label)->clear;
	}

	$o:actor->saveOrShowError;
}

sub showLabels($o, $cmd) {
	$o:ui->space;
	$o->showRememberedValues;
	$o:ui->space;
}

sub showRememberedValues($o) {
	my $hasLabel = 0;
	for my $child (sort { $a:id cmp $b:id } $o:actor->groupRoot->child('labels')->children) {
		my $record = $child->record;
		my $label = $o:ui->blue($o:ui->left(15, Encode::decode_utf8($child->label)));

		my $actorHash = CDS::Hash->fromBytes($record->child('actor')->bytesValue);
		my $storeUrl = $record->child('store')->textValue;
		my $keyPairFile = $record->child('key pair')->textValue;

		if (length $keyPairFile) {
			$o:ui->line($label, ' ', $o:ui->gray('key pair'), '    ', $keyPairFile);
			$hasLabel = 1;
		}

		if ($actorHash && length $storeUrl) {
			my $storeReference = $o:actor->blueStoreUrlReference($storeUrl);
			$o:ui->line($label, ' ', $o:ui->gray('account'), '     ', $actorHash->hex, ' on ', $storeReference);
			$hasLabel = 1;
		} elsif ($actorHash) {
			$o:ui->line($label, ' ', $o:ui->gray('actor'), '       ', $actorHash->hex);
			$hasLabel = 1;
		} elsif (length $storeUrl) {
			$o:ui->line($label, ' ', $o:ui->gray('store'), '       ', $storeUrl);
			$hasLabel = 1;
		}

		$o->showActorGroupLabel($label, $record->child('actor group'));
	}

	return if $hasLabel;
	$o:ui->line($o:ui->gray('none'));
}

sub showActorGroupLabel($o, $label, $record) {
	return if ! $record->contains('actor group');

	my $builder = CDS::ActorGroupBuilder->new;
	$builder->parse($record, 1);

	my $countActive = 0;
	my $countIdle = 0;
	my $newestActive = undef;

	for my $member ($builder->members) {
		my $isActive = $member->status eq 'active';
		$countActive += 1 if $isActive;
		$countIdle += 1 if $member->status eq 'idle';

		next if ! $isActive;
		next if $newestActive && $member->revision <= $newestActive->revision;
		$newestActive = $member;
	}

	my @line;
	push @line, $label, ' ', $o:ui->gray('actor group'), ' ';
	push @line, $newestActive->hash->hex, ' on ', $o:actor->blueStoreUrlReference($newestActive->storeUrl) if $newestActive;
	push @line, $o:ui->gray('(no active actor)') if ! $newestActive;
	push @line, $o:ui->green('  ', $countActive, ' active');
	my $discovered = $record->child('discovered')->integerValue;
	push @line, $o:ui->gray('  ', $o:ui->niceDateTimeLocal($discovered)) if $discovered;
	$o:ui->line(@line);
}
