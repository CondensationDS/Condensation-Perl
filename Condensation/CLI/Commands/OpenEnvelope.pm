# BEGIN AUTOGENERATED

sub register($class, $cds, $help) {
	my $node000 = CDS::Parser::Node->new(0);
	my $node001 = CDS::Parser::Node->new(0);
	my $node002 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&help});
	my $node003 = CDS::Parser::Node->new(1);
	my $node004 = CDS::Parser::Node->new(1);
	my $node005 = CDS::Parser::Node->new(0);
	my $node006 = CDS::Parser::Node->new(0);
	my $node007 = CDS::Parser::Node->new(1);
	my $node008 = CDS::Parser::Node->new(0);
	my $node009 = CDS::Parser::Node->new(0);
	my $node010 = CDS::Parser::Node->new(0);
	my $node011 = CDS::Parser::Node->new(1);
	my $node012 = CDS::Parser::Node->new(0);
	my $node013 = CDS::Parser::Node->new(1, {constructor => \&new, function => \&openEnvelope});
	$cds->addArrow($node001, 1, 0, 'open');
	$help->addArrow($node000, 1, 0, 'open');
	$node000->addArrow($node002, 1, 0, 'envelope');
	$node001->addArrow($node003, 1, 0, 'envelope');
	$node003->addArrow($node004, 1, 0, 'HASH', \&collectHash);
	$node003->addArrow($node007, 1, 0, 'OBJECT', \&collectObject);
	$node004->addArrow($node005, 1, 0, 'from');
	$node004->addArrow($node006, 1, 0, 'from');
	$node004->addDefault($node009);
	$node005->addArrow($node009, 1, 0, 'ACTOR', \&collectActor);
	$node006->addArrow($node011, 1, 1, 'ACCOUNT', \&collectAccount);
	$node007->addArrow($node008, 1, 0, 'from');
	$node007->addDefault($node011);
	$node008->addArrow($node011, 1, 0, 'ACTOR', \&collectActor);
	$node009->addArrow($node010, 1, 0, 'on');
	$node009->addDefault($node011);
	$node010->addArrow($node011, 1, 0, 'STORE', \&collectStore);
	$node011->addArrow($node012, 1, 0, 'using');
	$node011->addDefault($node013);
	$node012->addArrow($node013, 1, 0, 'KEYPAIR', \&collectKeypair);
}

sub collectAccount($o, $label, $value) {
	$o:senderHash = $value->actorHash;
	$o:store = $value->cliStore;
}

sub collectActor($o, $label, $value) {
	$o:senderHash = $value;
}

sub collectHash($o, $label, $value) {
	$o:hash = $value;
	$o:store = $o:actor->preferredStore;
}

sub collectKeypair($o, $label, $value) {
	$o:keyPairToken = $value;
}

sub collectObject($o, $label, $value) {
	$o:hash = $value->hash;
	$o:store = $value->cliStore;
}

sub collectStore($o, $label, $value) {
	$o:store = $value;
}

sub new($class, $actor) { bless {actor => $actor, ui => $actor->ui} }

# END AUTOGENERATED

# HTML FOLDER NAME open-envelope
# HTML TITLE Open envelope
sub help($o, $cmd) {
	my $ui = $o:ui;
	$ui->space;
	$ui->command('cds open envelope OBJECT');
	$ui->command('cds open envelope HASH on STORE');
	$ui->p('Downloads an envelope, verifies its signatures, and tries to decrypt the AES key using the selected key pair and your own key pair.');
	$ui->p('In addition to displaying the envelope details, this command also displays the necessary "cds show record …" command to retrieve the content.');
	$ui->space;
	$ui->command('cds open envelope HASH');
	$ui->p('As above, but uses the selected store.');
	$ui->space;
	$ui->command('… from ACTOR');
	$ui->p('Assumes that the envelope was signed by ACTOR, and downloads the corresponding public key. The sender store is assumed to be the envelope\'s store. This is useful to verify public and private envelopes.');
	$ui->space;
	$ui->command('… using KEYPAIR');
	$ui->p('Tries to decrypt the AES key using this key pair, instead of the selected key pair.');
	$ui->space;
}

sub openEnvelope($o, $cmd) {
	$o:keyPairToken = $o:actor->preferredKeyPairToken;
	$cmd->collect($o);

	# Get the envelope
	my $envelope = $o:actor->uiGetRecord($o:hash, $o:store, $o:keyPairToken) // return;

	# Continue by envelope type
	my $contentRecord = $envelope->child('content');
	if ($contentRecord->hashValue) {
		if ($envelope->contains('encrypted for')) {
			$o->processPrivateEnvelope($envelope);
		} else {
			$o->processPublicEnvelope($envelope);
		}
	} elsif (length $contentRecord->bytesValue) {
		if ($envelope->contains('head') && $envelope->contains('mac')) {
			$o->processStreamEnvelope($envelope);
		} else {
			$o->processMessageEnvelope($envelope);
		}
	} else {
		$o->processOther($envelope);
	}
}

sub processOther($o, $envelope) {
	$o:ui->space;
	$o:ui->pOrange('This is not an envelope. Envelopes always have a "content" section. The raw record is shown below.');
	$o:ui->space;
	$o:ui->title('Record');
	$o:ui->recordChildren($envelope, $o:actor->storeReference($o:store));
	$o:ui->space;
}

sub processPublicEnvelope($o, $envelope) {
	$o:ui->space;
	$o:ui->title('Public envelope');
	$o:ui->line($o:ui->gold('cds show record ', $o:hash->hex, ' on ', $o:actor->storeReference($o:store)));

	my $contentHash = $envelope->child('content')->hashValue;
	$o->showPublicPrivateSignature($envelope, $contentHash);

	$o:ui->space;
	$o:ui->title('Content');
	$o:ui->line($o:ui->gold('cds show record ', $contentHash->hex, ' on ', $o:actor->storeReference($o:store)));

	$o:ui->space;
}

sub processPrivateEnvelope($o, $envelope) {
	$o:ui->space;
	$o:ui->title('Private envelope');
	$o:ui->line($o:ui->gold('cds show record ', $o:hash->hex, ' on ', $o:actor->storeReference($o:store)));

	my $aesKey = $o->decryptAesKey($envelope);
	my $contentHash = $envelope->child('content')->hashValue;
	$o->showPublicPrivateSignature($envelope, $contentHash);
	$o->showEncryptedFor($envelope);

	$o:ui->space;
	if ($aesKey) {
		$o:ui->title('Content');
		$o:ui->line($o:ui->gold('cds show record ', $contentHash->hex, ' on ', $o:actor->storeReference($o:store), ' decrypted with ', unpack('H*', $aesKey)));
	} else {
		$o:ui->title('Encrypted content');
		$o:ui->line($o:ui->gold('cds get ', $contentHash->hex, ' on ', $o:actor->storeReference($o:store)));
	}

	$o:ui->space;
}

sub showPublicPrivateSignature($o, $envelope, $contentHash) {
	$o:ui->space;
	$o:ui->title('Signed by');
	if ($o:senderHash) {
		my $accountToken = CDS::AccountToken->new($o:store, $o:senderHash);
		$o:ui->line($o:actor->blueAccountReference($accountToken));
		$o->showSignature($envelope, $o:senderHash, $o:store, $contentHash);
	} else {
		$o:ui->p('The signer is not known. To verify the signature of a public or private envelope, you need to indicate the account on which it was found:');
		$o:ui->line($o:ui->gold('  cds show envelope ', $o:hash->hex, ' from ', $o:ui->underlined('ACTOR'), ' on ', $o:actor->storeReference($o:store)));
	}
}

sub processMessageEnvelope($o, $envelope) {
	$o:ui->space;
	$o:ui->title('Message envelope');
	$o:ui->line($o:ui->gold('cds show record ', $o:hash->hex, ' on ', $o:actor->storeReference($o:store)));

	# Decrypt
	my $encryptedContentBytes = $envelope->child('content')->bytesValue;
	my $aesKey = $o->decryptAesKey($envelope);
	if (! $aesKey) {
		$o:ui->space;
		$o:ui->title('Encrypted content');
		$o:ui->line(length $encryptedContentBytes, ' bytes');
		return $o->processMessageEnvelope2($envelope);
	}

	my $contentObject = CDS::Object->fromBytes(CDS::C::aesCrypt($encryptedContentBytes, $aesKey, CDS->zeroCTR));
	if (! $contentObject) {
		$o:ui->pRed('The embedded content object is invalid, or the AES key (', unpack('H*', $aesKey), ') is wrong.');
		return $o->processMessageEnvelope2($envelope);
	}

	#my $signedHash = $contentObject->calculateHash;	# before 2020-05-05
	my $signedHash = CDS::Hash->calculateFor($encryptedContentBytes);
	my $content = CDS::Record->fromObject($contentObject);
	if (! $content) {
		$o:ui->pRed('The embedded content object does not contain a record, or the AES key (', unpack('H*', $aesKey), ') is wrong.');
		return $o->processMessageEnvelope2($envelope);
	}

	# Sender hash
	my $senderHash = $content->child('sender')->hashValue;
	$o:ui->pRed('The content object is missing the sender.') if ! $senderHash;

	# Sender store
	my $senderStoreRecord = $content->child('store');
	my $senderStoreBytes = $senderStoreRecord->bytesValue;
	my $mentionsSenderStore = length $senderStoreBytes;
	$o:ui->pRed('The content object is missing the sender\'s store.') if ! $mentionsSenderStore;
	my $senderStore = scalar $mentionsSenderStore ? $o:actor->storeForUrl($senderStoreRecord->textValue) : undef;

	# Sender
	$o:ui->space;
	$o:ui->title('Signed by');
	if ($senderHash && $senderStore) {
		my $senderToken = CDS::AccountToken->new($senderStore, $senderHash);
		$o:ui->line($o:actor->blueAccountReference($senderToken));
		$o->showSignature($envelope, $senderHash, $senderStore, $signedHash);
	} elsif ($senderHash) {
		my $actorLabel = $o:actor->actorLabel($senderHash) // $senderHash->hex;
		if ($mentionsSenderStore) {
			$o:ui->line($actorLabel, ' on ', $o:ui->red($o:ui->niceBytes($senderStoreBytes, 64)));
		} else {
			$o:ui->line($actorLabel);
		}
		$o:ui->pOrange('The signature cannot be verified, because the signer\'s store is not known.');
	} elsif ($senderStore) {
		$o:ui->line($o:ui->red('?'), ' on ', $o:actor->storeReference($senderStore));
		$o:ui->pOrange('The signature cannot be verified, because the signer is not known.');
	} elsif ($mentionsSenderStore) {
		$o:ui->line($o:ui->red('?'), ' on ', $o:ui->red($o:ui->niceBytes($senderStoreBytes, 64)));
		$o:ui->pOrange('The signature cannot be verified, because the signer is not known.');
	} else {
		$o:ui->pOrange('The signature cannot be verified, because the signer is not known.');
	}

	# Content
	$o:ui->space;
	$o:ui->title('Content');
	$o:ui->recordChildren($content, $senderStore ? $o:actor->storeReference($senderStore) : undef);

	return $o->processMessageEnvelope2($envelope);
}

sub processMessageEnvelope2($o, $envelope) {
	# Encrypted for
	$o->showEncryptedFor($envelope);

	# Updated by
	$o:ui->space;
	$o:ui->title('May be removed or updated by');

	for my $child ($envelope->child('updated by')->children) {
		$o->showActorHash24($child->bytes);
	}

	# Expires
	$o:ui->space;
	$o:ui->title('Expires');
	my $expires = $envelope->child('expires')->integerValue;
	$o:ui->line($expires ? $o:ui->niceDateTime($expires) : $o:ui->gray('never'));
	$o:ui->space;
}

sub processStreamHead($o, $head) {
	$o:ui->space;
	$o:ui->title('Stream head');
	return $o:ui->pRed('The envelope does not mention a stream head.') if ! $head;
	$o:ui->line($o:ui->gold('cds open envelope ', $head->hex, ' on ', $o:actor->storeReference($o:store)));

	# Get the envelope
	my $envelope = $o:actor->uiGetRecord($head, $o:store, $o:keyPairToken) // return;

	# Decrypt the content
	my $encryptedContentBytes = $envelope->child('content')->bytesValue;
	my $aesKey = $o->decryptAesKey($envelope) // return;
	my $contentObject = CDS::Object->fromBytes(CDS::C::aesCrypt($encryptedContentBytes, $aesKey, CDS->zeroCTR)) // return {aesKey => $aesKey};
	my $signedHash = CDS::Hash->calculateFor($encryptedContentBytes);
	my $content = CDS::Record->fromObject($contentObject) // return {aesKey => $aesKey};

	# Sender
	my $senderHash = $content->child('sender')->hashValue;
	my $senderStoreRecord = $content->child('store');
	my $senderStore = $o:actor->storeForUrl($senderStoreRecord->textValue);
	return {aesKey => $aesKey, senderHash => $senderHash, senderStore => $senderStore} if ! $senderHash || ! $senderStore;

	$o:ui->pushIndent;
	$o:ui->space;
	$o:ui->title('Signed by');
	my $senderToken = CDS::AccountToken->new($senderStore, $senderHash);
	$o:ui->line($o:actor->blueAccountReference($senderToken));
	$o->showSignature($envelope, $senderHash, $senderStore, $signedHash);

	# Recipients
	$o:ui->space;
	$o:ui->title('Encrypted for');
	for my $child ($envelope->child('encrypted for')->children) {
		$o->showActorHash24($child->bytes);
	}

	$o:ui->popIndent;
	return {aesKey => $aesKey, senderHash => $senderHash, senderStore => $senderStore, isValid => 1};
}

sub processStreamEnvelope($o, $envelope) {
	$o:ui->space;
	$o:ui->title('Stream envelope');
	$o:ui->line($o:ui->gold('cds show record ', $o:hash->hex, ' on ', $o:actor->storeReference($o:store)));

	# Get the head
	my $streamHead = $o->processStreamHead($envelope->child('head')->hashValue);
	$o:ui->pRed('The stream head cannot be opened. Open the stream head envelope for details.') if ! $streamHead || ! $streamHead:isValid;

	# Get the content
	my $encryptedBytes = $envelope->child('content')->bytesValue;

	# Get the CTR
	$o:ui->space;
	$o:ui->title('CTR');
	my $ctr = $envelope->child('ctr')->bytesValue;
	if (length $ctr == 16) {
		$o:ui->line(unpack('H*', $ctr));
	} else {
		$o:ui->pRed('The CTR value is invalid.');
	}

	return $o:ui->space if ! $streamHead;
	return $o:ui->space if ! $streamHead:aesKey;

	# Get and verify the MAC
	$o:ui->space;
	$o:ui->title('Message authentication (MAC)');
	my $mac = $envelope->child('mac')->bytesValue;
	my $signedHash = CDS::Hash->calculateFor($encryptedBytes);
	my $expectedMac = CDS::C::aesCrypt($signedHash->bytes, $streamHead:aesKey, $ctr);
	if ($mac eq $expectedMac) {
		$o:ui->pGreen('The MAC valid.');
	} else {
		$o:ui->pRed('The MAC is invalid.');
	}

	# Decrypt the content
	$o:ui->space;
	$o:ui->title('Content');
	my $contentObject = CDS::Object->fromBytes(CDS::C::aesCrypt($encryptedBytes, $streamHead:aesKey, CDS::C::counterPlusInt($ctr, 2)));
	if (! $contentObject) {
		$o:ui->pRed('The embedded content object is invalid, or the provided AES key (', unpack('H*', $streamHead:aesKey), ') is wrong.') ;
		$o:ui->space;
		return;
	}

	my $content = CDS::Record->fromObject($contentObject);
	return $o:ui->pRed('The content is not a record.') if ! $content;
	$o:ui->recordChildren($content, $streamHead:senderStore ? $o:actor->storeReference($streamHead:senderStore) : undef);
	$o:ui->space;

	# The envelope is valid
	#my $source = CDS::Source->new($o:pool:keyPair, $o:actorOnStore, 'messages', $entry:hash);
	#return CDS::ReceivedMessage->new($o, $entry, $source, $envelope, $streamHead->senderStoreUrl, $streamHead->sender, $content, $streamHead);

}

sub showActorHash24($o, $actorHashBytes) {
	my $actorHashHex = unpack('H*', $actorHashBytes);
	return $o:ui->line($o:ui->red($actorHashHex, ' (', length $actorHashBytes, ' instead of 24 bytes)')) if length $actorHashBytes != 24;

	my $actorName = $o:actor->actorLabelByHashStartBytes($actorHashBytes);
	$actorHashHex .= '·' x 16;

	my $keyPairHashBytes = $o:keyPairToken->keyPair->publicKey->hash->bytes;
	my $isMe = substr($keyPairHashBytes, 0, 24) eq $actorHashBytes;
	$o:ui->line($isMe ? $o:ui->violet($actorHashHex) : $actorHashHex, (defined $actorName ? $o:ui->blue('  '.$actorName) : ''));
	return $isMe;
}

sub showSignature($o, $envelope, $senderHash, $senderStore, $signedHash) {
	# Get the public key
	my $publicKey = $o->getPublicKey($senderHash, $senderStore);
	return $o:ui->line($o:ui->orange('The signature cannot be verified, because the signer\'s public key is not available.')) if ! $publicKey;

	# Verify the signature
	if (CDS->verifyEnvelopeSignature($envelope, $publicKey, $signedHash)) {
		$o:ui->pGreen('The signature is valid.');
	} else {
		$o:ui->pRed('The signature is not valid.');
	}
}

sub getPublicKey($o, $hash, $store) {
	return $o:keyPairToken->keyPair->publicKey if $hash->equals($o:keyPairToken->keyPair->publicKey->hash);
	return $o:actor->uiGetPublicKey($hash, $store, $o:keyPairToken);
}

sub showEncryptedFor($o, $envelope) {
	$o:ui->space;
	$o:ui->title('Encrypted for');

	my $canDecrypt = 0;
	for my $child ($envelope->child('encrypted for')->children) {
		$canDecrypt = 1 if $o->showActorHash24($child->bytes);
	}

	return if $canDecrypt;
	$o:ui->space;
	my $keyPairHash = $o:keyPairToken->keyPair->publicKey->hash;
	$o:ui->pOrange('This envelope is not encrypted for you (', $keyPairHash->shortHex, '). If you possess one of the keypairs mentioned above, add "… using KEYPAIR" to open this envelope.');
}

sub decryptAesKey($o, $envelope) {
	my $keyPair = $o:keyPairToken->keyPair;
	my $hashBytes24 = substr($keyPair->publicKey->hash->bytes, 0, 24);
	my $child = $envelope->child('encrypted for')->child($hashBytes24);

	my $encryptedAesKey = $child->bytesValue;
	return if ! length $encryptedAesKey;

	my $aesKey = $keyPair->decrypt($encryptedAesKey);
	return $aesKey if defined $aesKey && length $aesKey == 32;

	$o:ui->pRed('The AES key failed to decrypt. It either wasn\'t encrypted properly, or the encryption was performed with the wrong public key.');
	return;
}
